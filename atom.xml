<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ZNing·慧响源创库]]></title>
  <link href="https://zning.me/atom.xml" rel="self"/>
  <link href="https://zning.me/"/>
  <updated>2021-11-27T10:49:43+08:00</updated>
  <id>https://zning.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Typora 1.0正式版发布并开启付费 我最喜欢的Markdown编辑器开始变现之路]]></title>
    <link href="https://zning.me/16379783407382.html"/>
    <updated>2021-11-27T09:59:00+08:00</updated>
    <id>https://zning.me/16379783407382.html</id>
    <content type="html"><![CDATA[
<p>昨天算是一个普通的周五，下班后约了妹子去吃饭看电影。一周工作的结束，将一些又是比赛又是写稿的事儿放诸脑后，一晚上不碰手机，爱咋咋地的感觉甚妙。</p>
<p>人嘛，有的时候摆脱一些道不同的事儿，也会开心得很。</p>
<p>今天清早一起来给朋友搜技术资料，结果突然发现在跟妹子吃饭的时候有个消息推送：Typora收费了。</p>
<span id="more"></span><!-- more -->
<p><img src="media/16379783407382/16379789386898.jpg" alt="" /></p>
<p>目前公布的政策是$14.99一个授权，每个授权可以激活三台设备。同时在FAQ里，作者明确写出了支持支付宝的付款途径，以及对于该费用是订阅制还是买断制的说明。</p>
<p><img src="media/16379783407382/16379783892745.jpg" alt="" /></p>
<p>下面这段挺有意思的其实，作者说明正常的版本升级无需付费。但有可能在主版本号升级时可能会需要重新付费，但仍要等待当时到来的政策声明。</p>
<p>这其实就给人一遐想空间了：版本买断付费制？但万一年内大版本就升级了呢？</p>
<p>当然，年内大版本不太现实，Typora这个编辑器我印象里已经用了至少四五年了，从我大学毕业前后就开始接触了它。五年期间的更新都是Beta版本，这个软件开发周期互联网公司直呼外行啊（狗头）。（腾讯游戏：你们都不懂，这才是内行）（狗头）</p>
<p>这款以“A truly minimal markdown editor”为宣传点的Markdown编辑器，以其跨平台、简洁易用、不失功能等特点，在我上手后就喜欢了，要知道当年其实还是MarkdownPad还在Windows流行的年代，但我一直觉得MarkdownPad过于笨重以及不知道为啥总感觉莫名其妙就卡顿一下，所以不是特别感冒。</p>
<p>当然Typora更让我看重一点的是他的跨平台，因为我手头基本上所有类型操作系统设备都会有（以Windows、macOS、Ubuntu为主）。虽然Markdown编辑器数不胜数，但其实选择一个能够全平台且操作都比较统一而且适合写作的编辑器，还是有点困难的。虽然VS Code、Sublime Text、Atom等全平台通用型编辑器对于Markdown支持性良好，但毕竟这几款是通用型编辑器，并没有对Markdown特性上做多少功夫。而Typora的出现，其实对于我来说填补了我的对于专用跨平台Markdown编辑器需求。</p>
<p><img src="media/16379783407382/16379808925044.jpg" alt="" /></p>
<p>毕竟作者一直有说关于正式发版之后会采用付费制，而且事实如此发生，用户的反应也没有那么大——当然我个人觉得也有可能是用户群也比较少吧，毕竟Markdown编辑器实在是太多了——不过，我非常乐见优秀软件的开发者能够通过合理的收费补足一些开发的成本，其实开源共享是一个主流方向，但是小而美的软件的小规模付费我觉得也是可以接受的，比如我就买了MWeb、Notability、GoodNotes等软件（但GoodNotes是真滴贵）。</p>
<p>不过我个人目前还暂时不会购买Typora的正式版本授权，主要是：</p>
<ol>
<li>我现在macOS是MWeb付费版本的用户，目前源创库网站其实就是MWeb生成的。再多买一个编辑器暂无必要（虽然因为工作等各种缘由，MWeb限制了我的创作和网站发版，在明年3月底张宁网5000天前会重构网站，届时将摆脱MWeb生成）。</li>
<li>Typora目前同MWeb在新特性功能上没有特别让我种草的特别功能，能够让我有非他不买的理由。</li>
<li>Typora目前采取订阅制还是付费制，仍然不确定。另外对于激活设备的限制对于我这个至少有四台需求设备的人来说非常不友好。另外我也有离线环境需要用编辑器，它只能离线激活，也少了付费的动力。</li>
</ol>
<p>最后，放一下Typora最后一个Beta版本的官方下载链接吧，转需：</p>
<p>Typora Beta 0.11.18：</p>
<ul>
<li>Windows x64： <a href="https://download.typora.io/windows/typora-update-x64-1117.exe">https://download.typora.io/windows/typora-update-x64-1117.exe</a></li>
<li>Windows x86： <a href="https://download.typora.io/windows/typora-update-ia32-1117.exe">https://download.typora.io/windows/typora-update-ia32-1117.exe</a></li>
<li>Linux x64： <a href="https://download.typora.io/linux/typora_0.11.18_amd64.deb">https://download.typora.io/linux/typora_0.11.18_amd64.deb</a></li>
<li>MacOS <a href="https://download.typora.io/mac/Typora-0.11.18.dmg">https://download.typora.io/mac/Typora-0.11.18.dmg</a></li>
</ul>
<blockquote>
<p>不要问我Windows的下载链接为啥是1117，你问作者去（狗头）</p>
</blockquote>
<p>希望Typora能够越来越好，不过也别搞出前段时间Notability买断改订阅制那种事件……说实话，Notability要不是用户一片骂声道歉改掉了方案，估计会对付费生态有很大影响……</p>
<p><img src="media/16379783407382/16379811679698.jpg" alt="" /></p>
<p><img src="media/16379783407382/16379811776193.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[陪伴前女友恩爱的那些年，我竟痛失35亿美元的财富？]]></title>
    <link href="https://zning.me/16337861814022.html"/>
    <updated>2021-10-09T21:29:41+08:00</updated>
    <id>https://zning.me/16337861814022.html</id>
    <content type="html"><![CDATA[
<p>今年国庆节，过的相当充实。</p>
<p>前三天在上海剪片子、爬格子、做节目、发表各种生产的内容、分析平台数据。中间几天陪一直没机会出门的父母去北京旅游。旅游的几个晚上还补了理应节前答应别人发的文稿，跟之前北京一起干活的同事约了个饭，顺便做了些视频技术教程的素材以备回上海剪一下发出去。然后回家再收拾行李返回上海。</p>
<p>我是感觉，肯定有人比我事儿还多，我这也不算啥了。不过国庆节在家的时候在翻家里老电脑的硬盘，发现了一些挺有意思的东西，大大小小的。其中，有一个大二上的一次创业活动的记录照片勾起了我的兴趣和回忆。</p>
<span id="more"></span><!-- more -->
<p><img src="media/16337861814022/IMG_1894.jpg" alt="IMG_1894" /></p>
<p>这是院学生会的一个部门组织的一次创业大赛活动，当时参赛也是机缘巧合。这个创业项目正好是我当时正在筹划的一个，只不过当时没有BP，只有一个思想在头脑里，并没有形成在纸上。但是正巧有个这个活动，然后院学生会这个部门跟我们院新闻中心关系还是不错的，反正不知道怎么着阴差阳错我就报了个名，把这个想法的东西做成了个PPT就去参赛了。现在想想当时还是有点勇的（狗头）</p>
<p><img src="media/16337861814022/16337885494481.jpg" alt="" /></p>
<p>我记得这个活动有十几支创业项目，最后我这个项目打分排名第四，我也经常在某些合适的场合在履历上写上这段经历。</p>
<p><img src="media/16337861814022/16337899188640.jpg" alt="" /></p>
<p>赛后合影期间，一个评委——一位天使风投VC——也留了联系方式，对这个项目也有点兴趣。不过因为我自己对这个项目的想法不是特别满意，一直觉得商业模式没有走通，不成熟；再加上参加比赛的团队成员真正想做这个项目的寥寥……</p>
<p>当然还有个最重要的，在比赛后没两个月，我脱单了（狗头）这个热恋嘛，经历过的人都懂。天时地利人和没有凑齐，也没有好意思跟这位天使投资者联系。这事儿也就算暂时搁置了。</p>
<p><img src="media/16337861814022/7293.JPG" alt="7293" /></p>
<p>其实这个项目的PPT我还有留，看到这个照片的时候，我又去翻看了下自己当时的PPT。其实在7年后的今天来看，经过市场验证后，有些东西确实是可以做的，比如这种众包模式的P2P，类似达达同城快送、顺丰同城快送的模式。</p>
<p>但我这个项目本身，当初我其实是以兼具社交的属性的商业模式去出发的，到现在为止仍没有做到。虽然在2016年前后，支付宝曾经上线过一个短暂的类似我这个设想的项目的功能，具体功能名我一时半会想不起来了，而且该功能也是有刻意向社交方向引导，但是该功能最终的社交功能也不了了之。这在我下面摘出来的PPT里，可窥见一斑。</p>
<p><img src="media/16337861814022/1-6.jpg" alt="1-6" /></p>
<p><img src="media/16337861814022/1-9.jpg" alt="1-9" /></p>
<p><img src="media/16337861814022/1-18.jpg" alt="1-18" /></p>
<p>不过我很好奇现在众包的市场市值咋样，毕竟现在的众包其实主要还是存在于外卖行业，在代送、代买和社区团购方面也有起色，但也是外卖促进了众包这样业态的多样化。虽然在近两年，由于某些平台本身的问题，导致了很多类似“困在算法之中的外卖员”、“平台将责任推卸给外卖小哥和顾客”等不愉快的事情发生。但是就商业模式本身来说，众包这种模式的确能够满足必要的需求市场，他对于促进商品的精准匹配和“最后一公里”，有了十足的增效。这种商业模式本身，其实是为了提高其他市场参与者的效率的一种模式。</p>
<p>于是，我就查了下现在比较大的达达平台的情况。不查不知道，把我吓一跳。</p>
<p><img src="media/16337861814022/16337897985270.jpg" alt="" /></p>
<p>啊这……达达上市一年多了我竟然一点也没印象……好吧原谅我近几年确实反应有点迟钝。</p>
<p>在该文下面，有对达达上市前这几年的简单回顾：</p>
<blockquote>
<p>2014年，蒯佳琪创办了达达物流，这是国内最早开始做众包物流的平台。</p>
<p>最初，达达选择社会上大量有闲置时间的人员来做配送，主要是保安、保姆、保洁这三类，作为一家同城速递信息服务公司，达达的订单最初大多来自饿了么、美团这样的外卖餐饮，随着新零售的发展，达达在日益便捷的最后一公里配送场景里崭露头角。2015年达达还曾尝试拓展外卖业务，不过在激烈的外卖竞争中“悬崖勒马”。</p>
<p>当年外卖订单的爆发式增长，曾让达达抓住了机遇，2016年4月15日，达达与京东到家合并，达达又拿到了大量的超市零售外送订单，蒯佳琪又一次“押对了”。这场被称为即时配送领域的收官之战，双方正式合并为“达达-京东到家”。</p>
</blockquote>
<p>恩？2014年？</p>
<p><img src="media/16337861814022/16337901018360.jpg" alt="" /></p>
<p>这么算，我是不是在这几年热恋时，错过了35个亿啊，还是美金（狗头）。</p>
<p>当然，这么说有点自己往脸上贴金的可耻行为了（狗头）其实这个项目本身当时增加社交属性的时候，也有人提到过关于这种社交属性如何做下去的问题。当时人人还是存在的，微信、QQ以及飞信（现在叫和飞信，中国移动推出的即时聊天软件）是大学生多种主流社交软件。我当时的想法就是，依靠这些平台来引流。</p>
<p>不过目前来看，如上文所说，这种众包的模式，由于增加了利益的交换，本身发展社交就很弱。毕竟挣钱已经很不容易了，还要加这么多人去认识，也是一种累人的功能，做大的可能性极小，还不如砍掉这个属性，直接作为一种提高市场要素流动效率、增加合理匹配资源的工具这种单一且垂直的商业模式来的更有意义。</p>
<p>但是看了下达达的发展历程，截图中的一句话也概括了它最终上市的艰辛：</p>
<blockquote>
<p>兴起于外卖，发展于新零售。</p>
</blockquote>
<p>对于我这个帮易帮的项目，在达达IPO后目前的主营业务中，这其实只是一部分罢了。虽然在起势阶段会有很稳定的现金流，商业模式也可以完全走通。但是他本身是有一个天花板的：由于作为提高效率的商业模式，其实这种项目也仅仅只是一种工具，对于依附的平台的依赖性会十分严重。只是因为在2014年以后到现在的这段时间，从外卖、代买，到代送、同城急送、社区团购，这些业态一直是变火的趋势，所以众包的模式也处于一种业绩上升的状态。</p>
<p>不过达达看到了这样的瓶颈，也及早的找到了破局，在新零售和社区团购方面占有了一定优势。至于后面如何发展，我觉得可以拭目以待下。不过我认为，众包的业态可能在同城这个细分垂直，可以往一个与快递、物流互补的方式，以及在文创方面获得一些意想不到的发展。</p>
<p>当然回到一开始我设想的这个项目，我个人觉得目前可以宣告这个项目本身是破产了的。当然总结其失败的原因，其实有很多因素，但我觉得如下这几条是比较重要的：</p>
<ol>
<li>创业的天时地利人和：天时——需求并不是在培养阶段或者爆发阶段，而是刚刚有起势，有入局者但入局者不多；地利——政策支持、资金支持、地域产业链或人力资源能够支持；人和——能够有一同创业的伙伴，有志同道合且思维一致，能够一起把这个事儿心无旁骛、毫无顾忌的干好。</li>
<li>商业模式走通极其重要，虽然我这个项目破产了，但是好在破产在襁褓之中（好像幸好的这个点有点奇怪（狗头））。并没有因为投入资金导致商业模式要重新调整，损失投资者资金。毕竟投资者还是相信你这个商业模式才投资给你资金，如果这个商业模式本身就有问题或者无法走通，浪费了投资者的金钱，也浪费了创业者的精力。所以商业模式一定要走通后才能动手。</li>
<li>商业模式走通需要有科学的方法去向市场要答案。这个项目本身其实BP都没有，后面虽然又有重启，也尝试运营了一段时间，但是由于对市场缺乏科学的摸索，没有总结反思，也是一个失败的原因了。</li>
<li>上面几点的问题，其实对于大学生创业来说基本很难解决，因此无法解决这些问题的话，不建议大学生盲目创业。尤其是开个网店参与地摊经济之类的就认为是创业了的思想更不要有。创业其实是一个严肃的事情，对自己负责，对投资人负责，对用户负责。</li>
<li>鱼和熊掌不可兼得。商业模式上很难有十全十美的既要又要，必要时该舍弃就得舍弃。<del>恋爱和赚钱好像也很难兼得啊，所以说创业建立事业不能谈恋爱？</del> <del>Robin Li等：？</del></li>
</ol>
<p>失败了不可怕，该总结的必然要总结。其实还有很多的因素，罗列起来就没完没了了。虽然可能在另外一个平行世界，我可能把这个商业模式走通了，然后有可能获得了这35个亿美金。但是在我现在的平行世界，在那些日子里，还是有甜甜的恋爱在陪伴着我是吧。</p>
<p>虽然，好像我现在的状态是，钱也飞了，爱情也没了？</p>
<p><del>看来，只有我受伤的世界完成了😂。</del></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我与GDG的故事]]></title>
    <link href="https://zning.me/16337015836679.html"/>
    <updated>2021-10-08T21:59:43+08:00</updated>
    <id>https://zning.me/16337015836679.html</id>
    <content type="html"><![CDATA[
<p>说起来，我跟谷歌的故事还是挺长的。</p>
<span id="more"></span><!-- more -->
<p>2009年，班里的英语老师为了与同学们能够在线学习英语，放置一些英语学习资料，以及有简单的论坛互动功能，我第一次使用了Google协作平台(即现在的Google Site)，这个网站就叫做English Heaven（下图）。当时对于Google的服务就有所吸引了。再后来到了2010年中考刚毕业，建站经历有两年多的我第一次使用 Google Webmaster Tools (即现在的Google Search Console)以及Google Adsense是我与谷歌密切接触的事件。众所周知，前者是Google提供给站长为他们提供SEO服务的工具，后者则是Google为站长提供的广告营收服务。虽然因为种种，最后并没有薅到在网站上挂着的Google Adsense广告的佣金——好像有二十多刀吧——不过还是因为此对于Google有着非同一般的感情。</p>
<p><img src="media/16337015836679/16337028356888.jpg" alt="" /></p>
<blockquote>
<p>现在还存在的Google 协作平台网站“English Heaven”</p>
</blockquote>
<p>而与GDG的故事，却姗姗来迟。时光流逝，转眼从高中走到了大学毕业，我也学习了自己一直感兴趣的计算机专业，也从事着相关的工作。期间呢，其实很多谷歌的服务我还是用着的。不过也是由于众所周知的原因，有些服务也逐步淡出了我们的生活，这虽有不舍，但仍然令人惋惜。不过在青岛读大学的一次机缘巧合，让我无意中了解到了GDG，才知道原来有GDG（Google Developer Group）这样的组织，将世界各地的开发者爱好者聚在一起，交流新技术，共享科技盛宴。</p>
<p><img src="media/16337015836679/IMG_4048.jpg" alt="IMG_4048" /></p>
<blockquote>
<p>时为GDG Shanghai活动中心一隅</p>
</blockquote>
<p><img src="media/16337015836679/IMG_4313.jpg" alt="IMG_4313" /></p>
<blockquote>
<p>时为GDG Shanghai活动中心活动合影</p>
</blockquote>
<p>毕业后，我来到了上海，也就顺其自然的参与进了一直心心念的GDG Shanghai了。说实话，在这里，有很多对技术感兴趣的大牛一起交流学习，所有人真的都是为了技术而走到了一起，这样的氛围真的很让人愉悦。这种氛围其实比起学习到了一种新的技术、新的编程思路和新的算法，更能让人欢欣鼓舞。</p>
<p><img src="media/16337015836679/IMG_0026.jpg" alt="IMG_0026" /></p>
<blockquote>
<p>GDG Shanghai 与个推联合技术分享活动上，摄影师捕捉到我的提问瞬间</p>
</blockquote>
<p>当然，GDG带给我的技能上的改变也是很多的，因为GDG的原因，我更多的了解了数据科学与CV相关的前沿发展，也更因为GDG得以有机会参加了第一次的Kaggle Days China的活动，这在我的职业生涯之中也是带给我了十足的帮助。</p>
<p><img src="media/16337015836679/16337836654714.jpg" alt="" /></p>
<blockquote>
<p>2019 Kaggle Days China (Beijing) 现场，最右侧的嘉宾为来自Google的Yufeng Guo，在YouTube的“AI Adventures”频道，专门讲解机器学习等相关知识</p>
</blockquote>
<p>虽然因为疫情，GDG活动现在绝大部分都只能在线上举办，但我仍希望GDG能够越办越好~感谢GDG，感谢GDG Shanghai，感谢马妹妹等GDG Shanghai的组织者和志愿者们的辛勤付出~希望GDG能够越发的发展壮大，也希望GDG的每一位成员在未来的发展之中都能受到GDG的良好氛围的感染，让自己的价值得以放大。</p>
<p><img src="media/16337015836679/16337836941411.jpg" alt="" /></p>
<blockquote>
<p>TensorFlow实训系列活动后合影，中间为主讲人董莉萍老师</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由Golang谈到的历史发展规律]]></title>
    <link href="https://zning.me/16317160011256.html"/>
    <updated>2021-09-15T22:26:41+08:00</updated>
    <id>https://zning.me/16317160011256.html</id>
    <content type="html"><![CDATA[
<p>最近一段时间在学习Golang，知道这款语言还在大二的时候，到现在Golang成了热门的新宠之一了。究其原因我也比较不解，但是看到各个公司都在用我感觉主要还是需求方多了所以热起来了罢了。</p>
<p>今下午搜资料的时候，发现了一个知乎专栏的文章，文章标题为《谈谈 Golang, 以及我走的一些弯路》作者是Karminski-牙医，看上面的title是前掘金的技术总监。至于文章本身关于Golang的相关踩坑没有什么需要说的，毕竟个人经验之谈。不过这位大佬提到了一个关于Erlang和Golang的发展历史和Erlang现在的处境，倒是让我有了些许联想。</p>
<span id="more"></span><!-- more -->
<p>帖子是这么说的：</p>
<blockquote>
<p>... 这是我第一次, 也是最后一次用 Erlang 给企业写应用.<br />
是的, Erlang 输在了这里. Erlang 的发明者 Joe Armstrong 有一篇文章 solving-the-wrong-problem 开头第一句就说了这么一句话:</p>
<blockquote>
<p>We're right and the rest of the world is wrong. We (that is Erlang folks) are solving the right problem, the rest of the world (non Erlang people) are solving the wrong problem.</p>
</blockquote>
<p>现在来看, 这句话简直太中二了, 大意就是, 错的不是我, 是世界.</p>
<p>Erlang 为什么没有在 CPU 主频无法继续提升, 而核心数猛增的这么好的生态下火起来. 这个问题其实大佬早就说过了. Erlang 也不是唯一一个倒下去的例子. Richard P. Gabriel ( Common Lisp的发明者之一 ) 在这篇文章中 The Rise of Worse is Better 很好地阐述了为什么 Lisp 会没人用, 这个道理同样适用于 Erlang 身上.</p>
<p>简单来讲就是, Erlang 太好了, 为了完美的解决问题导致设计的很难学很难使用. 曲高和寡. 而那些简单好用的垃圾, 才能流行起来.</p>
<p>很合理, 这个道理再简单不过了. 这也是为什么大家不去看书, 而是喜欢去听喜马拉雅听, 喜欢去看知乎, 喜欢去看掘金, 喜欢这些被咀嚼一遍的东西, 觉得学到了知识. 因为对大家来说, 看书太难了, 太痛苦了.</p>
</blockquote>
<p>帖子是2019年发的，时隔2年被我翻出来仔细阅读了一下。Erlang的发展到现在，其实很像昆曲，阳春白雪固然雅，然而曲高和寡。然后我又转念一想，好像这个时代的发展，让我们逐渐失去了对于阳春白雪的耐性了。人们困在了算法里追求着速度与效率，与短视频绑定很少输入长期的学习思考，问题使用现用现查也不再追求系统学习与思考了。反正有的是大佬和神犇在带着我们前进。</p>
<p>当然，并不是说这种发展是错误的。当今世界与历史上的世界必然是不同的，信息爆炸已然成为时代的主旋律。各种xGC产生的内容都源源不断的在各个平台各个渠道产生与传播，个中真真假假也是层出不穷。人们去处理这些事物就已经身心俱疲，可能没有耐心去沉淀自己的一些东西也是能够理解的——毕竟精力都耗光了。也因此，能够真正的静下心来，耐心去研究一个好东西，这种人本身就在这个社会是弥足珍贵的珍稀动物了。</p>
<p>所以这种Erlang的现象，在各处都随处可见：刚才提到的昆曲、没有耐心阅读的名著、躺在B站收藏夹里的公开课、堆在CAJ和PDF阅读器里的精选论文、能解决万事但极少有人翻阅的开发文档……</p>
<p>是这些内容没有用吗？不是，只是因为，我们的精力，都被吸收的过于干净了……</p>
<p>另外也让我想起了朋友最近一直在鄙视的vtuber/vup，TA的意思是要表演就要好好的拿出职业素质，“套个皮算什么”。不过我个人觉得这个反而方便了主播或者从业者节约时间去开播了，我也观察了一段时间目前这个领域的情况，虽然我是觉得目前这个领域从业者大多数都是聊聊天，真通过这个设计好自己的演艺发展路线的也是极少的。</p>
<p>但直到今天突然看到了这篇文章，我觉得现在vtuber/vup的出现，也是有种Erlang的意思：原来的都太复杂了，虽然美，但是咱们都简单点，我套个你愿意看的外壳，展现自己的才艺或者陪你唠嗑。你也愿意看这个外壳一起应援，就够了。哪还有啥现场不现场的问题啊，拿出我自己能干的，不要再耗费更多的精力了，开心就好，开心就好。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django使用local_settings.py实现本地个性化配置（网上互抄教程修正）]]></title>
    <link href="https://zning.me/16315381724367.html"/>
    <updated>2021-09-13T21:02:52+08:00</updated>
    <id>https://zning.me/16315381724367.html</id>
    <content type="html"><![CDATA[
<p>在Java开发的时候，我们都知道可以通过本地<code>application.properties</code>或者<code>application.xml</code>并可通过一些优先级设置，将远程配置中心的配置项，用我们本地的文件进行覆盖，以方便本地的开发和调试，并可以通过<code>.gitignore</code>控制防止提交到远程仓库。在Django内，其实也有这样的方法能够做这个事儿，那就是使用<code>local_settings.py</code>。在Django的<code>.gitignore</code>模板文件里面，对于这个文件是默认存在的，也就会在Git提交时无须担心其提交到远程仓库。</p>
<p>其实这玩意儿不是那么难理解，但是我今天在网上搜索相关资料的时候，发现有现有的教程都是同一篇互相抄，抄的源头也被我找到了是Stack Overflow，而且代码是有问题的。这篇文章其实主要是修正下网上的错误，以正视听。</p>
<span id="more"></span><!-- more -->
<p>我的开发环境：</p>
<blockquote>
<p>MacBook Pro (13-inch, 2020) / PyCharm 2021.1 / Python 3.9 / Django 3.2.5</p>
</blockquote>
<p>首先，在你工程的<code>settings.py</code>的结尾处添加如下代码：</p>
<pre><code class="language-python">try:
    from .local_settings import *
except ImportError:
    pass
</code></pre>
<blockquote>
<p>就是这个代码，网上互抄的全部都不行无法执行，错在了<code>local_settings</code>前面的<code>.</code>没了……</p>
</blockquote>
<p>这个代码的意义就在于尝试读取是否有<code>local_settings.py</code>这个文件，如果有的话，且在<code>settings.py</code>读入有问题时则读入覆盖配置。</p>
<p>然后，在你的<code>settings.py</code>的文件夹下新建<code>local_settings.py</code>，然后放置需要覆盖的参数即可，例如我的工程放置的如下：</p>
<pre><code class="language-python">from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

DEBUG = True

ALLOWED_HOSTS = ['*']

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'db',
        'USER': 'user',
        'PASSWORD': 'password',
        'HOST': '127.0.0.1',
        'PORT': '3306',
    },
    'lite': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
</code></pre>
<p>好了，就这么简单。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于元宇宙(Metaverse)：上周讨论的观点与未来的静待花开]]></title>
    <link href="https://zning.me/16311020572857.html"/>
    <updated>2021-09-08T19:54:17+08:00</updated>
    <id>https://zning.me/16311020572857.html</id>
    <content type="html"><![CDATA[
<p>今天元宇宙突然火了，有点神奇，不就是前两天头条收了个公司嘛，为啥市场延迟了这么长时间才反应……</p>
<p>难道是因为今天没啥概念可以拱火了？（狗头）</p>
<span id="more"></span><!-- more -->
<p>当然对于这个概念，其实好早就提出来了。摘要一下Wiki关于元宇宙（metaverse）的解释：</p>
<blockquote>
<p>The Metaverse is a collective virtual shared space, created by the convergence of virtually enhanced physical reality and physically persistent virtual space, including the sum of all virtual worlds, augmented reality, and the Internet. The word &quot;metaverse&quot; is made up of the prefix &quot;meta&quot; (meaning beyond) and the stem &quot;verse&quot; (a back-formation from &quot;universe&quot;); the term is typically used to describe the concept of a future iteration of the internet, made up of persistent, shared, 3D virtual spaces linked into a perceived virtual universe.</p>
<p>翻译：Metaverse是一个集体虚拟共享空间，由虚拟增强的物理现实和物理持久性虚拟空间（包括所有虚拟世界，增强现实和Internet的总和）的融合创建。“ metaverse”一词由前缀“ meta”和词干“ verse”组成；该术语通常用于描述由链接到感知虚拟世界的持久，共享的3D虚拟空间组成的互联网未来迭代的概念。</p>
</blockquote>
<p>这个概念来源于尼尔·斯蒂芬森1992 年的科幻小说《雪崩》中，近期由于这个概念在老扎（Mark Zuckerberg）的Facebook战略中处于突出的地位，而他也在各个公开场合对该概念进行了阐明。具体可以搜一搜他的发言新闻稿。我就不赘述了。</p>
<p>目前来看，元宇宙对于AR/VR的发展及其扩展应用都是有互相促进的作用的。其实正巧上个月的时候跟朋友有聊过这个话题，我和朋友当时的观点直接放图吧：</p>
<p><img src="media/16311020572857/16311027766042.jpg" alt="" /></p>
<p><img src="media/16311020572857/16311027611978.jpg" alt="" /></p>
<p>其实元宇宙这个，仍然是一个炒概念的活，当然有人炒概念就一定会有解释概念的人把这个概念做实。但是对于技术的人来说，这东西其实还是一些现有技术的融合罢了。只不过这个技术的融合，随着目前互联网基础设施（云计算、带宽、5G等）逐步普及而能够成为现实。</p>
<p>当然，对于上面两个图，我有两点还是想强调下的（狗头）：</p>
<ol>
<li>真正的元宇宙的设想应该归功于大刘！（吼叫状）三体万岁！世界属于……！（狗头）</li>
<li>我赞同朋友所说的，元宇宙的发展，真的不一定是Facebook能够领头。虽然Facebook其实现在来看对元宇宙挺重视的（毕竟是社交巨头，元宇宙作为文娱互联网必然与社交是离不开的）。当然，到底是谁，我觉得每个人心里都会有答案（我个人觉得这样的领头羊是分化的，技术领先在国外，应用普及领先在国内），我们拭目以待。</li>
</ol>
<p>最后附上两个元宇宙的两个图：</p>
<p><img src="media/16311020572857/16311031542810.jpg" alt="" /></p>
<p><img src="media/16311020572857/16311031599858.jpg" alt="" /></p>
<p>总之，静待花开，这可能是开启了人类能够进入一个新的社交和娱乐的时代的大门了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python GUI初步认识与C/S端发展之我见]]></title>
    <link href="https://zning.me/16310105700119.html"/>
    <updated>2021-09-07T18:29:30+08:00</updated>
    <id>https://zning.me/16310105700119.html</id>
    <content type="html"><![CDATA[
<p>今天翻了翻《Python编程（第四版）》，这本书其实买来还是有点久的，毕竟现在Python 3.9都出来了，这书是Python 3.1/3.2 Beta的示例。当然也暴露了我这书买来没怎么翻过的事实。（狗头）</p>
<p>其实翻书本来是想看看有没有写关于Python类的装饰符相关的东西，结果翻了下目录好像并没有。不过我发现了一个在Python世界一直没有关注过的东西：GUI。</p>
<span id="more"></span><!-- more -->
<p>其实对于我这个B/S死忠粉来说，对于C/S的应用几乎没有怎么编程经验，也就没怎么接触过GUI这块，无论是大学期间Java程序设计这门课讲GUI还是C# .net课上的GUI，相关的课程作业和实验设计我都是有点头疼的，emmmm 可能也跟我一直从事B/S相关事情有关系吧。</p>
<p>今天吸引来，主要是因为想了解下Python GUI比起Java和C#，有没有什么特点。</p>
<p>先说结论：Python自带GUI框架，能用；几行代码开个窗口，方便。果然人生苦短，我用Python。（狗头）</p>
<p>Python GUI框架主要有tkinter、wxPython、PyQt、PythonCard、Dabo等，而Python自带的是thinkter。简单的窗口启动代码如下：</p>
<pre><code class="language-py">from tkinter import *

Label(text=&quot;啥玩意&quot;).pack()
mainloop()
</code></pre>
<p>运行后如图：</p>
<p><img src="media/16310105700119/image-20210907160117089.png" alt="image-20210907160117089" /></p>
<p>咋说呢，三行代码起一个GUI，这是我第一个接触到的能干这个事儿的语言（当然时过境迁，现在估计有很多现代化语言都可以干这个事儿了，知道的大佬可以在评论区留言）。</p>
<p>再来点元素：</p>
<pre><code class="language-python">from tkinter import *
from tkinter.messagebox import showinfo

def reply():
    showinfo(title=&quot;恋爱循环&quot;, message=&quot;按钮按下去啦！&quot;)

window = Tk()
button = Button(window, text=&quot;快来点击&quot;, command=reply)
button.pack()
Label(text=&quot;啥玩意&quot;).pack()
window.mainloop()
</code></pre>
<p>运行后如图：</p>
<p><img src="media/16310105700119/image-20210907160305056.png" alt="image-20210907160305056" /></p>
<p>好！很好！很有精神！不算空行才9行代码，把Java需要写十几行实现的功能给搞定了。</p>
<p>Python GUI的面向对象写法以及窗口嵌套：</p>
<p>类定义文件<code>TestGUI.py</code>：</p>
<pre><code class="language-python">from tkinter import *
from tkinter.messagebox import showinfo

class TestGUI(Frame):
    def __init__(self, parent=None):
        Frame.__init__(self, parent)
        button = Button(self, text='按下去', command=self.reply)
        button.pack()

    def reply(self):
        showinfo(title=&quot;恋爱循环2&quot;, message=&quot;でも そんなんじゃ だーめ&quot;)
</code></pre>
<p>调用文件<code>bindgui.py</code>：</p>
<pre><code class="language-python">from tkinter import *
from TestGUI import TestGUI

main = Tk()
Label(main, text=__name__).pack()

popup = Toplevel()
Label(popup, text=&quot;绑定&quot;).pack(side=LEFT)
TestGUI(popup).pack(side=RIGHT)
main.mainloop()
</code></pre>
<p>运行后如图：</p>
<p><img src="media/16310105700119/image-20210907161408238.png" alt="image-20210907161408238" /></p>
<p>好了，Hello World就写到这了，我也不做代码讲解了。想多说下自己对于C/S端当下发展的理解。</p>
<p>其实很长一段时间我一直觉得在移动互联网的蓬勃发展，B/S端将逐步取代C/S端，一方面是因为越来越多的人用手机而不是PC，另一方面由于Web技术的进步，Web在全平台适配上已经不是什么难事，因此当初我认为C/S终将会走向没落，而B/S终究会成为最为重要的程序开发方式。</p>
<p>当然直到现在，我觉得我的判断还是对了一半的：B/S端确实成为了最为重要的程序开发方式，即使是App开发，使用Native开发的也要少于用WebView的。但是我失算的一点是，C/S端并没有走向没落，相反人家还活得好好的。究其原因我认为当时的判断忽略了两点：一是物联网IoT相关领域的发展，二是传统行业对于GUI软件的需求。</p>
<p>众所周知，近几年IoT其实发展的还是可以的，尤其是工业互联网和智能家居领域的相关技术发展，而这些数字化系统必不可少的需要配置相关的软件去操控这些物理设备，需要在系统启动后就能直接打开软件并进入相关界面，这个时候使用B/S其实并不是特别合适，因为毕竟浏览器这种方式还需要访问网址之类的东西。当然随着目前的发展，有些操控版已经换成了基于Android开发的App了，这种的倒是可以解决这个问题。</p>
<p>另外就是传统行业一些需求，其实并不是说他们的业务不适合B/S开发，而是技术债积累过多，对于系统的重构成本可能不太合算，这样的话反而使用C/S端更容易一些。而且据我所知C#的.net窗口开发在画界面方面是可以直接拖拽的，所以C/S编程相关的职位其实要求不是那么高，而换了B/S之后所有架构都要重新评估，引入了技术复杂度，对于一个非互联网的传统企业来说，IT本身就属于成本部门或稳定部门而不是利润来源部门，必然唯恐避之不及。这种客观存在的情况也是C/S一直存在的必要之一，当然相比第一个的增量，这一个仅仅是一个存量，并不能阻挡大势。</p>
<p>这就让我想起当年互联网兴起的时候，有人宣称书籍将会消亡，而再往前电视出现之后，有人也宣称过广播会消亡。虽然我们都知道事物都是螺旋上升的，旧事物会消亡，但是这个真正的“旧”的道理，是站在对人是否有用、有利、能可持续发展的角度来看的。书籍和广播固然是传统的，但他仍然是人们获取知识、交流思想和传输知识的有益渠道，只要这个作用没有消失，他们也不会消失，即使他们从历史的角度来说，确实是“旧”的。</p>
<p>拿过这样的思想，再来看待当下科技互联网的发展，其实所有的主流语言、开发模式、软件工程方式方法，都是这样的道理，只不过是你方唱罢我登场。The wheel turns, nothing is ever new.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[云、云原生、Serverless、云函数的小思考与腾讯云Serverless云函数Koa服务日志打印undefined的解决]]></title>
    <link href="https://zning.me/16309237786462.html"/>
    <updated>2021-09-06T18:22:58+08:00</updated>
    <id>https://zning.me/16309237786462.html</id>
    <content type="html"><![CDATA[
<p>最近在研究腾讯云的Serverless，发现云函数和无服务器化这块虽说国内与AWS Lambda差不多先后发展，但是目前来看一些便捷程度还是需要努力一把啊。</p>
<p>不过，整体而言，作为云时代的应用来说，FaaS、Serverless、云函数等基于云本身演化出来的SaaS产品，更代表了下一代云应用以及CNCF所贯彻的云原生的理念。毕竟作为云计算从2009年开始由亚马逊衍生发展，一直以来包括我在内，很多人对云上应用都持有一种保守的目光看待：云的服务与传统IDC提供的包括虚拟化服务在内的各种服务有什么区别吗？</p>
<span id="more"></span><!-- more -->
<p>其实在很长一段时间，这个问题无论云计算厂商如何吹的天花乱坠，仍然都摆脱不了云服务器本身与IDC相关服务的同质化情况。直到近两年，由各大厂商加盟组织的CNCF，开始对这个问题有了明确的思考与回答：真正的云的应用，应该是从云而生的（即云原生Cloud Native）。</p>
<p>当然，云原生的得以实现，离不开IaaS和PaaS自云计算兴起以来各路大神和开源社区的卓越贡献，毕竟作为云原生的土壤，云基础设施的稳健与巩固是云原生能够推广的关键。这也是我国在“十四五”期间将新一代大数据中心的建设纳入“新基建”七大领域之一的原因之一。</p>
<p>作为一名技术从业人员的角度来看，云原生将逐步降低应用的开发周期，提高应用迭代效率，尤其是对于中小企业和大企业中作为辅助相关的业务开发来说，云原生的应用场景和费用支出都是比传统应用架构开发模式的性价比更高。而云原生相关的开发岗位，预计也将会逐步进入各非互联网行业招聘信息的视野主流，而不仅仅只在互联网行业发展。</p>
<p>而从非技术从业角度来看，云原生不仅降低了应用开发周期，更可以降低非技术从业人员参与业务开发的门槛，在去年参加的腾讯云云开发CTO交流日北京站的技术沙龙活动上，可以看到厂商都在这方面有做很多努力：云开发的应用可预留更多可配置项目，让非技术人员可以根据业务需求及时调整，从而增加业务的快速启动。</p>
<p><img src="media/16309237786462/IMG_4199.jpg" alt="IMG_4199" /><br />
<img src="media/16309237786462/IMG_0932.jpeg" alt="IMG_0932" /></p>
<blockquote>
<p>去年参加腾讯云云开发CTO交流日·北京站，对于Serverless和云开发的现状有了一定了解</p>
</blockquote>
<p>不过这样的发展，对于一些只能CRUD相关业务系统的从业者来说不是什么好事，因为这些需求企业有了更具性价比的业务启动思路，可能开发只需要一个人，配合多个业务人员来做就可以，不需要太多开发相关岗位了。这在去年的CTO交流日活动上与其他与会者的交流中，是一个比较认同的点。</p>
<p>关于云原生时代的职业影响这个话题，可以回头有空再独立探讨。接下来解决一下实际问题：腾讯云Serverless Koa服务部署后日志打印Undefined的解决。</p>
<p>前两天有个需求，因为懒得搭建全套Web，因此瞄准了Serverless。不过我一直没怎么实际接触过Serverless部署，只能摸着石头过河。后来经过搜索和高人指点，最终选择了腾讯云Serverless的Node.js Koa的示例工程进行开发实现。当然Koa这个下一代Web Framework，我也是第一次使用，两眼一抹黑全部都是新的，都是要慢慢搞。</p>
<p>这其中就踩了一个坑：在传入post请求时，Demo工程打印的是<code>undefined</code>。如下图：</p>
<p><img src="media/16309237786462/image-20210906161400392.png" alt="image-20210906161400392" /></p>
<p><img src="media/16309237786462/image-20210906155927733.png" alt="image-20210906155927733" /></p>
<p>究其原因，其实还是挺简单的：因为腾讯云云函数服务提供的koa并没有引入<code>koa-bosyparser</code>这个组件，所以我们需要安装一下。</p>
<p>在这里也有个小坑：koa工程是在代码的<code>src</code>目录下，所以需要先进该目录操作。另外在操作时需要先将文件夹<code>node_module</code>、<code>yarn.lock</code>、<code>package-lock.json</code>全部删除。</p>
<p>后在头部加入该组件引用代码：</p>
<pre><code class="language-javascript">const bodyParser = require('koa-bodyparser')
</code></pre>
<p>之后修改<code>app.use(router.allowedMethods()).use(router.routes())</code>这行代码为：</p>
<pre><code class="language-javascript">app.use(router.allowedMethods()).use(bodyParser()).use(router.routes())
</code></pre>
<p>最后打开终端（这玩意是Coding的Cloud Studio，也就是VS Code的Web开源版本，跟VS Code用法完全一致）执行命令：</p>
<pre><code class="language-shell">yarn add koa-bodyparser
</code></pre>
<p>修改如图：</p>
<p><img src="media/16309237786462/image-20210906161013708.png" alt="image-20210906161013708" /></p>
<p>保存后，点击部署，部署完成后我们再测试一下：</p>
<p><img src="media/16309237786462/image-20210906161440946.png" alt="image-20210906161440946" /></p>
<p>大功告成。</p>
<p>最后给两张图，关于Serverless云函数创建Koa框架模板相关步骤：</p>
<ol>
<li>
<p>创建第一步：</p>
<p><img src="media/16309237786462/image-20210906154440510.png" alt="image-20210906154440510" /></p>
</li>
<li>
<p>创建第二步：</p>
<p><img src="media/16309237786462/image-20210906154718289.png" alt="image-20210906154718289" /></p>
</li>
<li>
<p>创建后初始化代码（post方法nice是我添加的）：</p>
<p><img src="media/16309237786462/image-20210906155747383.png" alt="image-20210906155747383" /></p>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向白嫖(Baipiao-oriented)的DevOps：将定时更新任务扔给Github Actions去做]]></title>
    <link href="https://zning.me/16288505655950.html"/>
    <updated>2021-08-13T18:29:25+08:00</updated>
    <id>https://zning.me/16288505655950.html</id>
    <content type="html"><![CDATA[
<p>最近有个需求，由于最近在某平台更新内容，其提供的订阅机制为RSS订阅分发，不过其中带有的一些额外的信息有点尴尬，并不能直接发送到其他同类型内容平台分发，因此想到了通过程序先将不适宜信息处理后，定期更新RSS文件到自己的Github Pages上，然后其他同类型内容平台获取的RSS为自己的Github Pages上托管的RSS文件。</p>
<span id="more"></span><!-- more -->
<p>于是，需求比较明确了：</p>
<ul>
<li>可以托管并执行程序，不仅可以获取RSS文件内容，又可以通过程序修改；</li>
<li>可以定时更新任务，并且根据更新任务内容push到仓库指定分支。</li>
</ul>
<p>我第一时间想起了Github Actions这个工具，众所周知，这个工具自2019年内测到向公众开放后，众多从业者将自己的博客的编译工作从本地线下扔到了Github Actions上；一些从业者所写的前端小玩意儿，都可以很轻松的通过Github Actions将工程迅速部署，提高了效率以及节约了成本。甚至一些有后端的工程，只需要寻（bai）找（piao）一个后端存储数据的地儿，就可以低成本甚至零成本搭建个人主页，这简直是一个十分有效提高生产率的东西啊！</p>
<p>不过说起来，其实Github Actions与Jenkins的功能是一致的，都是一个CI/CD的DevOps生产力工具，只不过Github Actions以其简单易用一经推出就受到了十分的欢迎。</p>
<p>虽然一直有知道这个功能，但是苦于没什么场景可以使用，今天这个需求正好让我能够使用Github Actions，零成本的解决一下需求。</p>
<p>首先，准备一下更新RSS的主程序<code>convertRSS.py</code>和<code>requirements.txt</code>：</p>
<pre><code class="language-python">import requests
import os, sys
import argparse

# the main get content codes
def get_url(url):
    # some server requests need headers, otherwise return empty
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
    }
    page = requests.get(url, headers = headers).content
    # convert to str within utf-8 encoding
    page = page.decode('utf-8')
    return page

# the main convert codes
def convert_content(content):
    content = content.replace(&quot;张宁网·源创库&quot;,&quot;张宁网·源创库&quot;)
    return content

if __name__ == '__main__':
    # need system args input
    arg_prsr = argparse.ArgumentParser()
    arg_prsr.add_argument('--url', required=True, type=str, default=&quot;&quot;, help = 'Required. Which one RSS Xml do you want to convert.')
    args = arg_prsr.parse_args(sys.argv[1:])
    url = args.url

    # place a flag to judge should write file to disk or not
    flag = False

    url_content = convert_content(get_url(url))
    url_list = url.split(&quot;/&quot;)

    if os.path.exists(url_list[-1]):
        with open(url_list[-1], 'r', encoding='utf-8') as file:
            if(file.read()!=url_content):
                flag = True
    else:
        # if the file dose not exist, the flag should placed True to convert first time
        flag = True

    if flag:
        # writing to disk codes
        with open(url_list[-1], 'w', encoding='utf-8') as file:
            file.write(url_content)
        print(&quot;The RSS Xml had update, convert done.&quot;)
        sys.exit(0)
    else:
        print(&quot;The RSS Xml have no change, convert abort.&quot;)
        sys.exit(1)
</code></pre>
<p>这里解释下我的程序的逻辑：通过系统执行传参<code>--url</code>将需要处理的RSS XML URL传值进入，后通过函数<code>get_url()</code>完成源文件的获取并转换成字符串，紧接着通过<code>convert_content()</code>函数处理替换源文件字符串。完成后紧接着判断本地是否有该文件，如果没有则直接创建，如果有则判断本地文件是否与处理替换后文件内容是否相同，如果不相同则覆盖修改本地文件完成更新，并以<code>0</code>返回值正常退出，如果相同则无需更新，以<code>1</code>返回值返回退出程序。</p>
<p>至于为什么设计这两个返回值，文末会讲到。</p>
<p>下面是该程序的<code>requirements.txt</code>，显然得，不再赘述：</p>
<pre><code class="language-text">requests==2.25.1
</code></pre>
<p>之后Github Actions创建一个仓库，把这俩文件放进去。</p>
<p>另外是需要去Settings-Developer settings-Personal access tokens（链接：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>）里面生成一个密钥，将这个密钥添加到仓库设置的Actions secrets（链接：<a href="https://github.com/%60%60%7Busername%7D/%60%60%7Breponame%7D/settings/secrets/actions">https://github.com/``{username}/``{reponame}/settings/secrets/actions</a>），在Actions secrets的名字即是配置文件引入的变量名，这里我的仓库叫<code>CONVERT_TOKEN</code>。</p>
<p><img src="media/16288505655950/FireShot%20Capture%20016%20-%20New%20personal%20access%20token%20-%20github.com.png" alt="FireShot Capture 016 - New personal access token - github.com" /></p>
<p><img src="media/16288505655950/FireShot%20Capture%20017%20-%20Actions%20secrets%20-%20github.com.png" alt="FireShot Capture 017 - Actions secrets - github.com" /></p>
<p>文件和密钥均备妥后，点击菜单标签Actions，后点击<code>set up a workflow yourself</code>，进入创建自己的工作流。</p>
<p>工作流创建文件使用的是YAML语法，具体使用文档可以查阅：<a href="https://docs.github.com/cn/actions">https://docs.github.com/cn/actions</a> 这里不再赘述更多用法，直接贴出本示例项目创建的工作流文件<code>convert-rss.yml</code>：</p>
<pre><code class="language-yaml">name: 'Convert RSS Actions'

on:
  schedule:
    - cron: '0,15,30,45 * * * *'

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - name: Checkout from repo
      uses: actions/checkout@main
      with:
        ref: main

    - name: Install Python latest
      uses: actions/setup-python@main
      with:
        python-version: '3.x'
        architecture: 'x64'

    - name: Install dependencies
      run: |
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    - name: Doing fetch
      run: python convertRSS.py --url https://zning.me/atom.xml

    - name: Commit files
      run: |
        git config --local user.email &quot;zhn038@gmail.com&quot;
        git config --local user.name &quot;ZNing&quot;
        git add .
        git commit -m &quot;提交RSS XML更新 $(date &quot;+%Y-%m-%d %H:%M:%S&quot;)&quot;
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.CONVERT_TOKEN }}
        branch: main
</code></pre>
<p>Github会在该分支仓库里创建<code>.github/workflow</code>文件夹，并在里面创建工作流文件<code>convert-rss.yml</code>，文件名没有任何要求，Github Actions会对该文件夹下所有<code>.yml</code>进行解析与执行。</p>
<p>这里稍微解释一下我自己这个工作流文件所干的事情：</p>
<ul>
<li>工作流名称为<code>Convert RSS Actions</code>；</li>
<li>工作流为定时计划工作流，工作时间是每隔15分钟一次；</li>
<li>工作流build有6个任务，顺序执行，每个步骤的具体是：
<ol>
<li>检出main仓库；</li>
<li>安装最新版Python 3；</li>
<li>根据仓库是否有<code>requirements.txt</code>安装Python依赖；</li>
<li>执行Python程序，对RSS XML进行处理；</li>
<li>对更新的RSS XML进行提交；</li>
<li>对更新的RSS XML进行推送至指定分支。</li>
</ol>
</li>
</ul>
<p><img src="media/16288505655950/FireShot%20Capture%20009%20-%20Actions%20%C2%B7%20zning1994_github-actions-examples%20-%20github.com.png" alt="FireShot Capture 009 - Actions · zning1994_github-actions-examples - github.com" /></p>
<p><img src="media/16288505655950/FireShot%20Capture%20012%20-%20New%20File%20-%20github.com.png" alt="FireShot Capture 012 - New File - github.com" /></p>
<p>创建好后，就等着Github Actions自己按计划调起Actions工作即可，不过根据实际测试，由于这玩意儿全球从业者估计使用的都挺多的，所以实际执行时间并不会完全按照设定的时间走，一般会晚个8-12分钟。</p>
<blockquote>
<p>仓库所有内容其实都可以本地创建，其中Actions的定义文件在本地创建<code>.github/workflow</code>文件夹后放置提交推送给Github也是可以的，只不过我这边为了演示方便，就不再在本地做操作了，直接在Github网页上直接将所有步骤都解决了。</p>
</blockquote>
<p><img src="media/16288505655950/FireShot%20Capture%20019%20-%20Actions%20%C2%B7%20zning1994_github-actions-examples%20-%20github.com.png" alt="FireShot Capture 019 - Actions · zning1994_github-actions-examples - github.com" /></p>
<p><img src="media/16288505655950/FireShot%20Capture%20020%20-%20Update%20convert-rss.yml%20%C2%B7%20zning1994_github-actions-examples@b2e36a9_%20-%20github.com.png" alt="FireShot Capture 020 - Update convert-rss.yml · zning1994_github-actions-examples@b2e36a9_ - github.com" /></p>
<p>这里解释一下刚才Python返回值的问题，因为我需要区分两种状态情况，而Github Actions是可以根据返回值判断该节点运行正常与否（详见：<a href="https://docs.github.com/cn/actions/creating-actions/setting-exit-codes-for-actions">https://docs.github.com/cn/actions/creating-actions/setting-exit-codes-for-actions</a>）只要是0就认为是正常，非0则是异常，且异常不会继续执行接下来的节点。</p>
<p>而我的需求其实就正好是，如果有更新则提交并推送仓库，如果没有则终止即可。因此上面的Python程序才会设置如此的返回值。</p>
<blockquote>
<p>不过可能是我Python程序有点小问题，发现如果内容相同的时候，后台程序也会提交更新，但是这个情况出现的很随机，有的时候又比对相同1值退出，正常返回错误。目前不太清楚这是为什么，欢迎知道的大佬在评论区留言。</p>
</blockquote>
<p><img src="media/16288505655950/FireShot%20Capture%20022%20-%20%E6%8F%90%E4%BA%A4RSS%20XML%E6%9B%B4%E6%96%B0%202021-08-13%2007_50_01%20%C2%B7%20zning1994_github-actions-examples@e_%20-%20github.com.png" alt="FireShot Capture 022 - 提交RSS XML更新 2021-08-13 07_50_01 · zning1994_github-actions-examples@e_ - github.com" /></p>
<p><img src="media/16288505655950/FireShot%20Capture%20022%20-%20%E6%8F%90%E4%BA%A4RSS%20XML%E6%9B%B4%E6%96%B0%202021-08-13%2007_50_01%20%C2%B7%20zning1994_github-actions-examples@e_%20-%20github.com%20-2-.png" alt="FireShot Capture 022 - 提交RSS XML更新 2021-08-13 07_50_01 · zning1994_github-actions-examples@e_ - github.com -2-" /></p>
<p>最后，本文示例程序正常开源，协议MIT，欢迎自取使用：</p>
<p>Github：<a href="https://github.com/zning1994/github-actions-examples">https://github.com/zning1994/github-actions-examples</a></p>
<p>Gitee镜像：<a href="https://gitee.com/zning/github-actions-examples">https://gitee.com/zning/github-actions-examples</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速通过中转方式下载GitHub/GitLab仓库]]></title>
    <link href="https://zning.me/16237631542826.html"/>
    <updated>2021-06-15T21:19:14+08:00</updated>
    <id>https://zning.me/16237631542826.html</id>
    <content type="html"><![CDATA[
<p>近期由于众所周知的原因，GitHub又不是特别好使，已经影响到了正常的pull/clone和push操作了。不过还好我的push主要还是在自己的网站更新上，但是pull/clone可是容易让人耽误事儿的啊。为此我经常使用Gitee（原称“码云”）做仓库中转。</p>
<p>本文就简单的介绍一下如何使用Gitee中转GitHub/GiLab仓库吧。</p>
<span id="more"></span><!-- more -->
<blockquote>
<p><strong>注意：</strong> 本操作仅限于从GitHub Clone仓库操作，不能Push。如果是Push受阻，您可能需要提高一定的上网技术才能解决该问题了。</p>
</blockquote>
<p>首先，登陆<code>gitee.com</code>，没有账号可以先注册，如果有开源中国账号的可以直接关联注册。</p>
<p>登陆后，在左上角<code>+</code>处找到<code>从GitHub/GitLab导入仓库</code>，单击进入。</p>
<p><img src="media/16237631542826/%E6%88%AA%E5%B1%8F2021-06-15%2021.39.18.png" alt="截屏2021-06-15 21.39.18" /></p>
<p>在如下显示的页面，在Git仓库地址粘贴你需要clone的仓库地址，Gitee会自动去GitHub拉取信息，如果你需要拉取的仓库在Gitee已有同学拉取过且设置为开源，他还会提示你该仓库已被拉取的地址。图上我以拉取最近微服务消息队列新宠Apache Pulsar为例演示。</p>
<p><img src="media/16237631542826/16237648054426.jpg" alt="" /></p>
<blockquote>
<p><strong>注意：</strong> 他人拉取的仓库不一定是最新的，有可能人家在半年前拉取过就没再更新过，你需要自己点进去看是否是你的需要。</p>
</blockquote>
<p>如果没有需要调整或者输入的，点击<code>导入</code>按钮即可。等待Gitee给你拉取完仓库即可。</p>
<p><img src="media/16237631542826/%E6%88%AA%E5%B1%8F2021-06-15%2021.48.40.png" alt="截屏2021-06-15 21.48.40" /></p>
<p>拉取完毕，在你的主页里就有这个仓库啦~</p>
<p><img src="media/16237631542826/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png" alt="未标题-1" /></p>
<p>Gitee仓库（左）和GitHub仓库（右）对比如上图。这样你在本地再clone你Gitee的仓库即可，例如我的这个仓库：</p>
<pre><code class="language-shell">git clone git@gitee.com:zning/pulsar.git
</code></pre>
<p>仓库路径右侧有个刷新图标，如果你过段时间仓库更新，需要再次clone或者需要pull的话，可以点击该按钮先更新自己的Gitee仓库，后在本地pull即可。</p>
<blockquote>
<p><strong>注意：</strong> Gitee仓库对于更新操作是，删除仓库内容重新全量克隆，而不是执行<code>git pull</code>命令，所以谨记不要在这个仓库上提交任何分支和任何修改，以免丢失信息。</p>
</blockquote>
<p>Gitee除了可以clone任意的GitHub仓库以外，也可以关联自己的GitHub账号，快速将自己GitHub仓库clone到Gitee。相当方便。</p>
<p><img src="media/16237631542826/Pasted%20Image%202021-06-15%2022-01-58.png" alt="Pasted Image 2021-06-15 22-01-58" /></p>
<blockquote>
<p>**PS：**最后声明，这篇文章早在一年前的7月就打算写了，奈何一直拖着没交付。[Doge] 当初是答应同事要写的，现在把这个事儿补上。[Doge]</p>
<p><img src="media/16237631542826/IMG_8872.jpg" alt="IMG_8872" /></p>
</blockquote>
<blockquote>
<p><img src="media/16237631542826/Screenshot_2021-06-15-21-29-06-841_com.tencent.mm.jpg" alt="Screenshot_2021-06-15-21-29-06-841_com.tencent.mm" /></p>
</blockquote>
<blockquote>
<p>今晚文章交付了，看大佬考完试的交付物了。[Doge]</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Chrome 91开始封禁10080端口 基金从业资格考试报名系统受影响 附临时解决方案]]></title>
    <link href="https://zning.me/16236378724281.html"/>
    <updated>2021-06-14T10:31:12+08:00</updated>
    <id>https://zning.me/16236378724281.html</id>
    <content type="html"><![CDATA[
<p>今日是个好日子，端午节。在这个插艾草、盼安康的日子里，本周六的基金从业考试开始打印准考证了。</p>
<p>我报名了6月的这次考试，本来到点登录打印准考证是个再平常不过的事情，结果……</p>
<span id="more"></span><!-- more -->
<p><img src="media/16236378724281/%E6%88%AA%E5%B1%8F2021-06-14%2010.17.42.png" alt="截屏2021-06-14 10.17.42" /></p>
<p>沃日？什么鬼？网站挂了？不过我发现一个很奇怪的地方，就是访问报错。<code>ERR_UNSAFE_PORT</code>，从来没见过的报错。</p>
<p>于是我网上一查，发现Google Chrome其实早在2014年就维护了一个“默认非安全端口列表”以拦截通过浏览器发起的不安全请求。这个列表有点长，其实是一些高危服务所在端口，例如22和23。但是……查了下，一堆文章提供的端口列表并没有<code>10080</code>端口啊。查了下Chrome源代码</p>
<p><a href="https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc?view=markup#l68">https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc?view=markup#l68</a></p>
<p>上面好像也没有10080。是哪里出问题了吗？</p>
<p>后来我搜了下资料，原来Google Chrome刚刚在91版本更新了端口的Block List，将10080端口加入了。</p>
<p><img src="media/16236378724281/%E6%88%AA%E5%B1%8F2021-06-14%2010.29.46.png" alt="截屏2021-06-14 10.29.46" /></p>
<p>究其原因，是Google Chrome社区开发者早在年初就讨论的关于防止10080端口在NAT Slipstreaming 2.0攻击中被滥用的问题。四月确认更新源码封禁，并在近期91版本实施。</p>
<p><img src="media/16236378724281/%E6%88%AA%E5%B1%8F2021-06-14%2010.48.11.png" alt="截屏2021-06-14 10.48.11" /></p>
<p>比较尴尬的是，中国证券投资基金业协会基金从业资格考试报名网站就是用的10080，这就导致了文章一开头出现的错误。</p>
<p>临时的解决方案其实很简单，就是<strong>更换浏览器</strong>。虽然网上有可以直接强制打开不安全端口的方法，但是这增加了安全风险，如果不是专业人士十分不建议去跟风操作。目前低于91版本的Chrome，以及Safari和Edge还是可以使用该端口访问网站，所以影响还是可以解决的。</p>
<p>（看社区所反馈，Firefox已经跟Chrome同步封禁，因为没有具体再搜版本号因此没有写Firefox）</p>
<p>但是目前从开源社区讨论的情况来看，10080端口集体封禁是大势所趋，希望中国证券投资基金业协会早点更新下基金从业资格考试报名网站，修改下访问端口，以保证未来的考试工作正常进行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Django近期总结 - 2021-06-06]]></title>
    <link href="https://zning.me/16229817791761.html"/>
    <updated>2021-06-06T20:16:19+08:00</updated>
    <id>https://zning.me/16229817791761.html</id>
    <content type="html"><![CDATA[
<p>周五公司给买的键盘到货了，毕竟我自己不太会买这么贵的键盘……不过这个键盘的布局由于键数缩小到60，键位改变了不少。为了熟悉一下键盘，整理一下近期的一些经验，以飨读者。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%BD%BF%E7%94%A8django-rest-framework%E6%8F%90%E7%A4%BA-could-not-resolve-url-for-hyperlinked-relationship-using-view-name-user-detail" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Django REST Framework 提示<code>Could not resolve URL for hyperlinked relationship using view name &quot;user-detail&quot;</code></h2>
<p>经过查询，由于我在app里的<code>urls.py</code>里设定了namespace名称，因此在Django设置序列化的文件<code>serializers.py</code>中，需要在<code>serializers.HyperlinkedIdentityField</code>中指定<code>view_name</code>的名称，例如：</p>
<pre><code class="language-python">class UserSerializer(serializers.HyperlinkedModelSerializer):
    url = serializers.HyperlinkedIdentityField(view_name=&quot;myapp:user-detail&quot;)

    class Meta:
    model = User
    fields = ('url', 'username')
</code></pre>
<p>至此，该问题解决。</p>
<h2><a id="django-models%E5%A4%84%E7%90%86-select%E5%BD%A2%E5%BC%8F%E5%AD%97%E6%AE%B5%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Django Models 处理Select形式字段经验总结</h2>
<p>其实还是挺简单的，由于我的需求只需要在Django后台页面显示，所以只需要在Models那里处理一下就好了。由于我需要的字段比较多，因此在app目录下新建了一个文件<code>cons.py</code>专门存储字段。</p>
<p>以下是模型文件<code>models.py</code>：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
from django.db import models
from .cons import SALCATEGORIES
from .cons import YEAR
from .cons import MONTH
from .cons import ORG

# Create your models here.
class Salary(models.Model):
    month = models.CharField('月',max_length=50, choices=MONTH)
    year = models.CharField('年',max_length=10, choices=YEAR)
    org = models.CharField('组织名',max_length=100, choices=ORG)
    create_timestamp = models.DateTimeField('创建时间',auto_now_add=True)
    change_timestamp = models.DateTimeField('修改时间',auto_now=True)
    def __str__(self):
        return dict(YEAR)[self.year]+dict(MONTH)[self.month]+'_'+dict(ORG)[self.org]

    class Meta:
        db_table = 'salary'
</code></pre>
<p><code>cons.py</code>文件引入的内容如下：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
SALCATEGORIES = (
    ('shubas','应发 - 基本工资'),
    ('shupos','应发 - 岗位工资'),
    ('shupls','应发 - 绩效工资'),
    ('shuotr','应发 - 其他'),
    ('wihuem','扣缴 - 失业保险'),
    ('wihmed','扣缴 - 医疗保险'),
    ('wihold','扣缴 - 养老保险'),
    ('wihgjj','扣缴 - 公积金'),
    ('wihbgj','扣缴 - 补充住房公积金'),
    ('wihotr','扣缴 - 其他'),
    ('relsal','实发 - 实发工资'),
    ('relotr','实发 - 其他'),
)

YEAR = (
    ('2020','2020年'),
    ('2021','2021年'),
    ('2022','2022年'),
    ('2023','2023年'),
    ('2024','2024年'),
    ('2025','2025年'),
    ('2026','2026年'),
    ('2027','2027年'),
    ('2028','2028年'),
)

MONTH = (
    ('01','01月'),
    ('02','02月'),
    ('03','03月'),
    ('04','04月'),
    ('05','05月'),
    ('06','06月'),
    ('07','07月'),
    ('08','08月'),
    ('09','09月'),
    ('10','10月'),
    ('11','11月'),
    ('12','12月'),
)

ORG = (
    ('abc','中国abc公司'),
    ('cde','上海cde公司'),
)
</code></pre>
<p>这个键值对，存储的是前面的键，显示的是后面的值</p>
<p>上面的这个形式，对于该变量的类型也是一个挺有趣的东西。众所周知<code>( )</code>是个元组的初始化标志，正常来说元组是不能直接转换为字典的，但是上面这样的变量是可以正常转换的，请见如下测试代码和输出：</p>
<pre><code class="language-python">print(type(ORG))
for i in ORG:
    print(i[0]+&quot;_&quot;+i[1])
    print(type(i))

print(type(dict(ORG)))
print(dict(ORG))
for i in dict(ORG):
    print(i)
    print(type(i))
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">&lt;class 'tuple'&gt;
abc_中国abc公司
&lt;class 'tuple'&gt;
cde_上海cde公司
&lt;class 'tuple'&gt;
&lt;class 'dict'&gt;
{'abc': '中国abc公司', 'cde': '上海cde公司'}
abc
&lt;class 'str'&gt;
cde
&lt;class 'str'&gt;
</code></pre>
<p>回到实现上来。最终我需要的后台显示情况如下：</p>
<p><img src="media/16229817791761/16229839637075.jpg" alt="" /></p>
<p><img src="media/16229817791761/16229839876474.jpg" alt="" /></p>
<p>数据库表存储情况如下：</p>
<p><img src="media/16229817791761/Pasted%20Screenshot%202021-06-06%2020-54-18.png" alt="Pasted Screenshot 2021-06-06 20-54-18" /></p>
<p>这里我们介绍一下Django里模型<code>Field</code>的<code>choices</code>字段：</p>
<blockquote>
<p>一个 <a href="https://docs.python.org/3/glossary.html#term-sequence">sequence</a> 本身由正好两个项目的迭代项组成（例如 <code>[(A，B)，(A，B)...]</code> ），作为该字段的选择。如果给定了选择，它们会被 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#validating-objects">模型验证</a> 强制执行，默认的表单部件将是一个带有这些选择的选择框，而不是标准的文本字段。</p>
</blockquote>
<blockquote>
<p>每个元组中的第一个元素是要在模型上设置的实际值，第二个元素是人可读的名称。例如：</p>
</blockquote>
<blockquote>
<pre><code class="language-python"></code></pre>
</blockquote>
<p>YEAR_IN_SCHOOL_CHOICES = [<br />
('FR', 'Freshman'),<br />
('SO', 'Sophomore'),<br />
('JR', 'Junior'),<br />
('SR', 'Senior'),<br />
('GR', 'Graduate'),<br />
]</p>
<pre><code class="language-plain_text">
&gt; 一般来说，最好在模型类内部定义选择，并为每个值定义一个合适的名称的常量：

&gt; ```python
&gt; from django.db import models
&gt; 
&gt; class Student(models.Model):
    FRESHMAN = 'FR'
    SOPHOMORE = 'SO'
    JUNIOR = 'JR'
    SENIOR = 'SR'
    GRADUATE = 'GR'
    YEAR_IN_SCHOOL_CHOICES = [
        (FRESHMAN, 'Freshman'),
        (SOPHOMORE, 'Sophomore'),
        (JUNIOR, 'Junior'),
        (SENIOR, 'Senior'),
        (GRADUATE, 'Graduate'),
    ]
    year_in_school = models.CharField(
        max_length=2,
        choices=YEAR_IN_SCHOOL_CHOICES,
        default=FRESHMAN,
    )
&gt; 
    def is_upperclass(self):
        return self.year_in_school in {self.JUNIOR, self.SENIOR}
&gt; ```

&gt; 虽然你可以在模型类之外定义一个选择列表，然后引用它，但在模型类内定义选择和每个选择的名称，可以将所有这些信息保留在使用它的类中，并帮助引用这些选择（例如，`Student.SOPHOMORE` 将在导入 `Student` 模型的任何地方工作）。

&gt; 你还可以将你的可用选择收集到可用于组织目的的命名组中：

&gt; ```
MEDIA_CHOICES = [
    ('Audio', (
            ('vinyl', 'Vinyl'),
            ('cd', 'CD'),
        )
    ),
    ('Video', (
            ('vhs', 'VHS Tape'),
            ('dvd', 'DVD'),
        )
    ),
    ('unknown', 'Unknown'),
]
</code></pre>
<blockquote>
<p>每个元组中的第一个元素是应用于该组的名称。第二个元素是一个二元元组的迭代，每个二元元组包含一个值和一个可读的选项名称。分组后的选项可与未分组的选项结合在一个单一的列表中（如本例中的 <code>'unknown'</code> 选项）。</p>
</blockquote>
<blockquote>
<p>对于每一个设置了 <code>choice</code> 的模型字段，Django 会添加一个方法来检索字段当前值的可读名称。参见数据库 API 文档中的 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#django.db.models.Model.get_FOO_display"><code>get_FOO_display()</code></a>。</p>
</blockquote>
<blockquote>
<p>请注意，选择可以是任何序列对象——不一定是列表或元组。这让你可以动态地构造选择。但是如果你发现自己把 <code>chips</code> 魔改成动态的，你可能最好使用一个合适的的带有 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 的数据库表。 <code>chips</code> 是用于静态数据的，如果有的话，不应该有太大的变化。</p>
</blockquote>
<blockquote>
<p>每当 <code>choices</code> 的顺序变动时将会创建新的迁移。</p>
</blockquote>
<blockquote>
<p>除非 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.Field.blank"><code>blank=False</code></a> 与 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.Field.default"><code>default</code></a> 一起设置在字段上，否则包含 <code>&quot;---------&quot;</code> 的标签将与选择框一起呈现。要覆盖这种行为，可以在 <code>choices</code> 中添加一个包含 <code>None</code> 的元组，例如 <code>(None, 'Your String For Display')</code> 。另外，你也可以在有意义的地方使用一个空字符串来代替 <code>None</code> ——比如在 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.CharField"><code>CharField</code></a>。</p>
</blockquote>
<p>最后，新设备镇楼压轴。这可是近几年手头设备最贵的一年了。</p>
<p><img src="media/16229817791761/IMG_8731.jpg" alt="IMG_8731" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[告辞了，但没有完全告辞]]></title>
    <link href="https://zning.me/16223375496772.html"/>
    <updated>2021-05-30T09:19:09+08:00</updated>
    <id>https://zning.me/16223375496772.html</id>
    <content type="html"><![CDATA[
<p>今日手续的完成，标志着我已正式从农行离职了。</p>
<p>关于离职，这是一个思前想后的结果，这是一个艰难的决定。</p>
<p>衷心感谢农行近三年来的培养和鼓励。感谢数据中心各位领导、同事的支持，共同建设运维平台提高生产运维工作效率与质量。感谢2020年在人行数研所借调期间各行同事、各厂同学的支持、协助，在疫情这个特殊时段齐心保障首次数字人民币消费券试点工作顺利完成。更感谢一起码代码、查BUG、做变更的各位大佬们，此生有幸、共愿坦途。</p>
<p>最近半年多一直没有更新过网站了，一方面是近期各种资格考试和培训把业余时间占满了，没来得及总结近期技术积累；另一方面也在考虑行业发展规划方面的事情。</p>
<p>今天这篇，除了告辞，也想简单说一下个人对于目前IT运维，主要以应用与系统层的领域的愚见。</p>
<span id="more"></span><!-- more -->
<p>当下IT运维发展，在容器、微服务的大规模使用和传统裸机、虚拟化存量维护的现状下，逐步在技术形态上两极分化：一个方向上，以科技公司、互联网公司和开源团队为主要推动力的前沿技术，将容器与微服务进行规模化、网格化，继而提出了新的运维需求——服务自治、故障自愈、智能监控，因此逐步形成了云原生、Serverless、FaaS、IoC、无代码化等新业务开发和运维方式方法与模式；另一个方向上，传统运维——指纯手工操作占比60%以上、裸机偏多、虚化资源半自动或完全手工等特征——看似没有了领域市场，然而事实上该场景在中小企业、传统行业信息科技事业部等相关职能部门仍大量存在。</p>
<p>一个事物在同一个时刻出现两极分化时，必然会在某个节点选择方向。就应用系统层运维来说，目前节点就是前沿技术发展替代传统方式的爆发起点之时。只不过这个爆发点对于科技互联网企业，早在五年前就启动了。其他领域的传导没有那么快，也是十分正常的。毕竟对于科技互联网企业，技术的革新和快速迭代是他们的主要营收业务，但对于其他企业来说这只是业务支持，按照“互联网黑话”的说法就叫“IT赋能”。</p>
<p>当下前沿技术发展的路径，其实总体来看，是“小而美”的发展策略。要说“小而不美”那是前五年的话，近几年提出的自治、自愈，以及Serverless、无代码化技术的正式投产，是从“不美”到“美”的一种“转型宣言”。一个微服务集群就像是一个城池里的各种角色的人，即亚当·斯密在《国富论》总结提到的工业革命后的社会化分工，每个人在整个社会体系里面专业化的干一件事，将生产力以指数级提升，国民生产总值不断累积加，共同建设发展同一座城池。一个个容器或pods只干一两件事，他们之间相互通讯交流，共同推动了整个业务的正常运转。</p>
<p>在第一次、第二次软件工程危机前的面向过程编程方法兴盛之时，其实这也是“小而美”的时代，但由于业务的发展，单个文件的“小而美”被人为变”大“了。危机后，面向对象编程方法将“小而美”细化到代码内部实现，而对外一个单体程序则是庞然大物。而现阶段的”小而美“则是把代码内部实现和功能最小化，但是放眼到整个系统来看则是把复杂性上升到了系统层面。这么来看，历代软件工程的革新都想从简从美改善，但最终只不过将无序熵从一个领域转为另外一个领域罢了。从这个角度来看，前沿技术或许也不是什么前沿技术，更像是高智商人群设计的游戏规则，各种矛盾转移的”甩锅内卷大赛“。当然，这种看法有点戏谑了。</p>
<p>而这种发展路径，必然将无序熵从开发人员转移到了运维人员。原来的软件工程的开发模式——面向过程到面向对象——是一种开发人员的内部优化，现在的技术革新解放开发人员的同时改变运维人员的工作模式——运维人员也需要相当的代码功底才能做好运维工作，因为一个容器或pod所关联的，仅仅是一个功能，甚至是一个方法或函数的代码，这是一种操作系统与代码强绑定的关系。也由此，SRE发展出了DevOps，DevOps发展出了多个业态方向。</p>
<p>所以，现在的IT运维，尤其是应用与系统层领域，成了一个两面包夹芝士：开发人员由于前沿技术革新，不断提出运维新要求；用户、业务方或领导由于对前沿技术革新并不完全理解，对于运维人员工作内容上的忍耐度越来越低。</p>
<p>解决这样的窘境，可能只有开发运维干一件事才能解决，那就是共同声明：我们联合！</p>
<p>说是简单说点，结果写到这发现扯了这么多。以后公众号将持续更新，去年开的几个栏目：“源产控”系列、“慧响悦书”系列，以及正常的技术总结、日常评谈，都会持续跟进。至于更新频率嘛我尽量完成周更。</p>
<p>所以，没有完全告辞之意就在此了。欢迎关注慧响公众号，一起交流~不见不散~</p>
<p align="right">2021年5月28日 于上海陆家嘴</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决Elasticsearch SQL命令行启动报错 ./x-pack-env: No such file or directory]]></title>
    <link href="https://zning.me/15951488866193.html"/>
    <updated>2020-07-19T16:54:46+08:00</updated>
    <id>https://zning.me/15951488866193.html</id>
    <content type="html"><![CDATA[
<p>今天在云服务器上，通过下载源码包完成有认证配置的Elasticsearch部署后，准备执行如下命令进入Elasticsearch SQL进行一些SQL语句的操作：</p>
<span id="more"></span><!-- more -->
<pre><code class="language-shell">bin/elasticsearch-sql-cli uri=http://elastic:ESabc+2333@10.66.66.2:9200/
</code></pre>
<p>但执行后，发现使用<code>bin/elasticsearch-sql-cli</code>登录时，出错提示<code>./x-pack-env: No such file or directory</code>，莫名其妙，遂即查看下该脚本，内容如下：</p>
<pre><code class="language-shell">#!/bin/bash

# Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
# or more contributor license agreements. Licensed under the Elastic License;
# you may not use this file except in compliance with the Elastic License.

source &quot;`dirname &quot;$0&quot;`&quot;/elasticsearch-env

source &quot;`dirname &quot;$0&quot;`&quot;/x-pack-env

CLI_JAR=$(ls $ES_HOME/bin/elasticsearch-sql-cli-*.jar)

exec \
  &quot;$JAVA&quot; \
  -jar &quot;$CLI_JAR&quot; \
  &quot;$@&quot;
</code></pre>
<p>其中有效行第二行的<code>source &quot;`dirname &quot;$0&quot;`&quot;/x-pack-env</code>看来执行起来有问题，估计是在依赖导入生效时找不到路径。经过一番折腾，解决了该问题，即将该行替换为如下命令：</p>
<pre><code class="language-shell"># source &quot;`dirname &quot;$0&quot;`&quot;/x-pack-env
source /usr/share/elasticsearch/bin/x-pack-env
</code></pre>
<p>即将引入依赖的路径写死即可，使用时请根据实际路径修改<code>x-pack-env</code>的指向路径。</p>
<p>修改完后，再用刚才的命令启动Elasticsearch SQL，正常进入，完美结局。</p>
<p>后来又仔细查找了下资料，发现该问题是Elasticsearch 7.4版本的一个小bug，在Elasticsearch 7.8的包内，<code>bin/elasticsearch-sql-cli</code>这个脚本内容已经修改为：</p>
<pre><code class="language-shell">#!/bin/bash

# Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
# or more contributor license agreements. Licensed under the Elastic License;
# you may not use this file except in compliance with the Elastic License.

source &quot;`dirname &quot;$0&quot;`&quot;/elasticsearch-env

source &quot;$ES_HOME&quot;/bin/x-pack-env

CLI_JAR=$(ls &quot;$ES_HOME&quot;/bin/elasticsearch-sql-cli-*.jar)

exec \
  &quot;$JAVA&quot; \
  &quot;$XSHARE&quot; \
  -jar &quot;$CLI_JAR&quot; \
  &quot;$@&quot;
</code></pre>
<p>也就是说，如果Elasticsearch 7.8安装时，操作系统环境变量内<code>$ES_HOME</code>能够正确设置的话，就可以正常启动Elasticsearch SQL了。这样比直接修改产品本身脚本来说要规范的多了。</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<ol>
<li><a href="https://stackoverflow.com/questions/59420831/elasticsearch-7-sql-cli-x-pack-env-no-such-file-or-directory-error">Elasticsearch 7 SQL CLI : ./x-pack-env: No such file or directory error - Stack Overflow</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“源产控”系列（三）在CentOS 8上使用Elastic Stack: Elasticsearch/Kibana 7.8的部署与认证配置]]></title>
    <link href="https://zning.me/15950655748460.html"/>
    <updated>2020-07-18T17:46:14+08:00</updated>
    <id>https://zning.me/15950655748460.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本篇为慧响技术角“源产控”专题系列第3篇文章。</p>
</blockquote>
<!-- -->
<blockquote>
<p>慧响技术角“源产控”专题，将聚焦开源、国产化、自主可控三个方向的技术，以操作系统、中间件、数据库、程序应用等为粗分类，更新相关技术的发展趋势、探究技术核心的深度使用、系统总结技术整体架构，为对相关技术的学习者提供可观的资料，亦为个人同步学习总结的笔记，以飨读者。</p>
</blockquote>
<p>本篇对在CentOS 8上使用Elastic Stack套件中的Elasticsearch、Kibana进行简要总结，对Elasticsearch 7.8.0的部署、认证设置与Kibana 7.8.0的配套部署进行了详细总结。未来对在CentOS 8上使用Elastic Stack相关套件，将陆续更新其使用总结、性能调优等方面的系列文章，敬请期待。</p>
<span id="more"></span><!-- more -->
<ul>
<li><a href="#elastic-stack%E4%BB%8B%E7%BB%8D">Elastic Stack介绍</a></li>
<li><a href="#elasticsearch-7-8%E7%9A%84%E9%83%A8%E7%BD%B2">Elasticsearch 7.8的部署</a>
<ul>
<li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Ayum%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85">方式一：<code>YUM</code>方式安装</a></li>
<li><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%B8%8B%E8%BD%BDrpm%E5%8C%85%E6%89%8B%E5%B7%A5%E5%AE%89%E8%A3%85">方式二：下载<code>RPM</code>包手工安装</a></li>
<li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85">方式三：源码安装</a></li>
</ul>
</li>
<li><a href="#elasticsearch-7-8%E7%9A%84%E9%85%8D%E7%BD%AE">Elasticsearch 7.8的配置</a></li>
<li><a href="#elasticsearch-7-8%E7%9A%84%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE">Elasticsearch 7.8的认证功能配置</a></li>
<li><a href="#kibana%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE">Kibana的部署与配置</a></li>
</ul>

<h2><a id="elastic-stack%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elastic Stack介绍</h2>
<p>提起Elastic Stack，就不得不提到ELK。ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了Beats工具所以已改名为Elastic Stack。</p>
<p>Elastic Stack包含：</p>
<ul>
<li>
<p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，RESTful风格接口，多数据源，自动搜索负载等。详细可参考Elasticsearch权威指南。</p>
</li>
<li>
<p>Logstash主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为C/S架构，client端安装在需要收集日志的主机上，Server端负责将收到的各节点日志进行过滤、修改等操作在一并发往Elasticsearch上去。</p>
</li>
<li>
<p>Kibana也是一个开源和免费的工具，Kibana可以为 Logstash 和 Elasticsearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p>
</li>
<li>
<p>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、CPU、I/O等资源消耗比较高。相比 Logstash，Beats所占系统的CPU和内存几乎可以忽略不计。</p>
</li>
</ul>
<h2><a id="elasticsearch-7-8%E7%9A%84%E9%83%A8%E7%BD%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elasticsearch 7.8的部署</h2>
<h3><a id="%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Ayum%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方式一：<code>YUM</code>方式安装</h3>
<p>输入如下命令，下载安装公共签名证书：</p>
<pre><code class="language-shell">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch
</code></pre>
<p>在目录<code>/etc/yum.repos.d/</code>下新建文件<code>elasticsearch.repo</code>，文件内容填写如下：</p>
<pre><code class="language-repo">[elasticsearch]
name=Elasticsearch repository for 7.x packages
baseurl=https://artifacts.elastic.co/packages/7.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=0
autorefresh=1
type=rpm-md
</code></pre>
<p>添加好后，直接执行<code>yum -y install --enablerepo=elasticsearch elasticsearch</code>安装即可。</p>
<h3><a id="%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%B8%8B%E8%BD%BDrpm%E5%8C%85%E6%89%8B%E5%B7%A5%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方式二：下载<code>RPM</code>包手工安装</h3>
<p>执行如下命令，进行安装：</p>
<pre><code class="language-shell">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0-x86_64.rpm;
wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0-x86_64.rpm.sha512;
shasum -a 512 -c elasticsearch-7.8.0-x86_64.rpm.sha512;
rpm --install elasticsearch-7.8.0-x86_64.rpm;
</code></pre>
<blockquote>
<p>**注意：**若<code>shasum</code>提示找不到命令，请输入<code>yum -y install perl-Digest-SHA</code>进行依赖安装。</p>
</blockquote>
<!-- -->
<blockquote>
<p>**提示：**鉴于Elastic网站为国外，下载速度极慢，可选择国内镜像地址，例如华为云的镜像，下载地址：<a href="https://mirrors.huaweicloud.com/elasticsearch/7.8.0/">https://mirrors.huaweicloud.com/elasticsearch/7.8.0/</a></p>
</blockquote>
<p>安装完成，系统提示如下：</p>
<pre><code class="language-shell">### NOT starting on installation, please execute the following statements to configure elasticsearch service to start automatically using systemd
 sudo systemctl daemon-reload
 sudo systemctl enable elasticsearch.service
### You can start elasticsearch service by executing
 sudo systemctl start elasticsearch.service
Created elasticsearch keystore in /etc/elasticsearch/elasticsearch.keystore
[/usr/lib/tmpfiles.d/elasticsearch.conf:1] Line references path below legacy directory /var/run/, updating /var/run/elasticsearch → /run/elasticsearch; please update the tmpfiles.d/ drop-in file accordingly.
</code></pre>
<h3><a id="%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方式三：源码安装</h3>
<p>如有更为灵活的需求，可通过官网下载Elasticsearch源码包进行部署。首先需建立用户属组：</p>
<pre><code class="language-shell">groupadd -g 888 elasticsearch;
useradd -g elasticsearch -m -u 888 elasticsearch;
</code></pre>
<p>后通过官网或镜像下载地址下载，解压到需要部署的文件夹：</p>
<pre><code class="language-shell">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0-linux-x86_64.tar.gz;
tar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz -C /usr/share/;
mv /usr/share/elasticsearch-7.8.0/ /usr/share/elasticsearch;
chown -R elasticsearch:elasticsearch /usr/share/elasticsearch;
</code></pre>
<h2><a id="elasticsearch-7-8%E7%9A%84%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elasticsearch 7.8的配置</h2>
<p>部署完成后就进入配置环节了，在配置之前我们需要知道的是进程文件和配置文件所在地。通过上述方式一、二安装，进程文件路径在<code>/usr/share/elasticsearch</code>，配置文件路径在<code>/etc/elasticsearch</code>。通过上述方式三安装，进程文件路径在解压文件路径，例如示例给出的<code>/usr/share/elasticsearch</code>，配置文件在进程文件路径下的<code>config</code>文件夹内。</p>
<p>在配置文件路径下有一个文件叫<code>jvm.options</code>，修改其中的<code>-Xms</code>、<code>-Xmx</code>两行参数来调整jvm的初始化堆大小以及最大堆大小。该值建议设置为操作系统内存的40%~50%。注：<code>-Xms</code>与<code>-Xmx</code>相同。例：若虚拟机内存为8G，可设置为如下参数：</p>
<pre><code class="language-options">-Xms4g
-Xmx4g
</code></pre>
<p>或者</p>
<pre><code class="language-options">-Xms4096m
-Xmx4096m
</code></pre>
<p>在配置文件路径下有一个文件叫<code>elasticsearch.yml</code>文件，对该文件进行配置以使集群启动：</p>
<pre><code class="language-yaml"># 集群名称，集群中所有节点统一
cluster.name: Elasticsearch-Cluster
# 当前节点名，自定义但集群内不允许重复
node.name: node-1
node.attr.rack: r1
# 下方数据和日志存放路径请按照实际情况修改路径
# 通过方法一、二安装，默认路径已存在，通过方法三安装，请指定存在的路径
path.data: /var/lib/elasticsearch
path.logs: /var/logs/elasticsearch
bootstrap.memory_lock: true
# 当前节点内网IP地址，虽也可以设置为0.0.0.0但建议还是按此设置
network.host: 10.66.66.1
http.port: 9200
# 集群中所有节点地址
discovery.seed_hosts: [&quot;10.66.66.1&quot;, &quot;10.66.66.2&quot;,&quot;10.66.66.3&quot;]
# 集群中所有节点名，应与集群所有节点的node.name一致
cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;,&quot;node-3&quot;]
</code></pre>
<p>另外，在启动Elasticsearch 7.8之前需先做些准备工作。首先编辑文件<code>/etc/security/limits.conf</code>，在尾部增加如下配置：</p>
<pre><code class="language-shell">elasticsearch      soft    nofile  100000
elasticsearch      hard    nofile  100000
elasticsearch      soft    memlock unlimited
elasticsearch      hard    memlock unlimited
elasticsearch      soft    nproc   4096
elasticsearch      hard    nproc   4096
</code></pre>
<p>编辑文件<code>/etc/sysctl.conf</code>，根据文件内已有内容，调整或新增如下配置：</p>
<pre><code class="language-shell">vm.swappiness=10
vm.max_map_count=262144
</code></pre>
<p>添加完成后，执行<code>sysctl -p</code>。</p>
<p>最后修改<code>/etc/hosts</code>文件，增加Elasticsearch集群主机名，例如：</p>
<pre><code class="language-shell">10.66.66.1  node-1
10.66.66.2  node-2
10.66.66.3  node-3
</code></pre>
<p>Elasticsearch内置Java，无需再在系统层再次部署Java。</p>
<p>完成配置后即可启动，方法一、二可通过<code>systemctl</code>命令进行启停：</p>
<pre><code class="language-shell">systemctl start elasticsearch;
systemctl stop elasticsearch;
systemctl restart elasticsearch;
</code></pre>
<p>如需开启开机自启，可通过如下命令开启：</p>
<pre><code class="language-shell">systemctl daemon-reload;
systemctl enable elasticsearch;
</code></pre>
<p>方法三启动可通过如下命令进行启停：</p>
<pre><code class="language-shell"># 启动
/usr/share/elasticsearch/bin/elasticsearch -d -p /usr/share/elasticsearch/pid;
# 停止
esid=$(cat /usr/share/elasticsearch/pid &amp;&amp; echo);
kill -SIGTERM $esid;
</code></pre>
<p>启动后可以执行如下命令，查看启动日志、集群节点发现、主节点选举是否正常：</p>
<pre><code class="language-shell"># 路径请注意：1. 按照配置文件设置的日志存放路径寻找；2. 按照实际集群名输入日志文件名
tail -f /var/logs/elasticsearch/Elasticsearch-Cluster.log;
# 按照方法一、二安装后也可以通过如下命令查看Elasticsearch进程情况
systemctl status elasticsearch;
</code></pre>
<p>也可以通过如下网址浏览器或<code>curl</code>命令访问直接获取Elasticsearch返回的集群健康检查信息：</p>
<pre><code class="language-shell">curl -XGET http://node-1:9200/_cluster/health?pretty
</code></pre>
<p>也可以在浏览器直接访问机器的<code>9200</code>端口，可展示如下页面：</p>
<p><img src="media/15950655748460/2020-7-18-003.png" alt="Elasticsearch启动成功后9200端口默认访问页" /></p>
<h2><a id="elasticsearch-7-8%E7%9A%84%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elasticsearch 7.8的认证功能配置</h2>
<p>Elasticsearch默认启动后，<code>9200</code>端口通过设定的Host IP是可以随意访问的，这十分不安全。为了保证一定的安全性，我们可以修改<code>elasticsearch.yml</code>文件里<code>http.port</code>字段，修改默认端口，以及增加访问时必须帐密认证访问。</p>
<p>自Elasticsearch 6.8开始，Elastic将部分X-Pack付费功能免费开放使用，其中就有基础认证功能，因此在Elasticsearch 6.8以后，可直接使用Elasticsearch自带的认证功能。而之前的版本，则需要一个开源插件叫做elasticsearch-http-basic，作者仓库地址：<a href="https://github.com/Asquera/elasticsearch-http-basic">https://github.com/Asquera/elasticsearch-http-basic</a> 。然而目前此仓库已封版不再更新，因此建议如需使用Elasticsearch，不要使用Elasticsearch 6.8以前的版本。</p>
<p>接下来我们配置Elasticsearch 7.8的认证功能，首先在某一台集群节点中，进入进程文件路径，执行如下命令，创建一个证书颁发机构：</p>
<pre><code class="language-shell">bin/elasticsearch-certutil ca;
</code></pre>
<p>一路回车即可，中间有设置CA的密码，无需设置。完成后将在进程文件路径目录生成文件<code>elastic-stack-ca.p12</code>。后继续在该台已生成证书颁发机构的集群节点继续执行如下命令，创建一个证书与私钥：</p>
<pre><code class="language-shell">bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12;
</code></pre>
<p>一路回车即可，中间有设置证书的密码，无需设置。完成后将在进程文件路径目录生成文件<code>elastic-certificates.p12</code>。完成生成后，将该文件拷贝到其他机器的相同路径，集群所有机器修改两个文件的属组：</p>
<pre><code class="language-shell">chown -R elasticsearch:elasticsearch *.p12;
</code></pre>
<p>集群所有机器建立软连接到配置文件路径下，示例如下，具体路径请修改为实际路径：</p>
<pre><code class="language-shell">ln -s /usr/share/elasticsearch/elastic-certificates.p12 /etc/elasticsearch/elastic-certificates.p12;
ln -s /usr/share/elasticsearch/elastic-stack-ca.p12 /etc/elasticsearch/elastic-stack-ca.p12;
</code></pre>
<p>配置<code>elasticsearch.yml</code>：</p>
<pre><code class="language-yaml"># 设置集群互信通信端口9300
transport.port: 9300
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;
http.cors.allow-headers: Authorization
# 开启X-Pack的安全认证
xpack.security.enabled: true
# 开启X-Pack的集群内互信安全认证，与上面安全认证开关同步必开
xpack.security.transport.ssl.enabled: true
# 验证模式为证书模式
xpack.security.transport.ssl.verification_mode: certificate
# 配置证书路径
xpack.security.transport.ssl.keystore.path: elastic-certificates.p12
xpack.security.transport.ssl.truststore.path: elastic-certificates.p12
# 如果需要启用SSL/TLS通过HTTPS访问ES集群，再添加如下配置
xpack.security.http.ssl.enabled: true
xpack.security.http.ssl.keystore.path: elastic-certificates.p12
xpack.security.http.ssl.truststore.path: elastic-certificates.p12
xpack.security.http.ssl.client_authentication: none
</code></pre>
<p>修改<code>discovery.seed_hosts</code>字段配置，增加集群互信通信端口<code>9300</code>，例如：</p>
<pre><code class="language-shell">discovery.seed_hosts: [&quot;10.66.66.1:9300&quot;, &quot;10.66.66.2:9300&quot;,&quot;10.66.66.3:9300&quot;]
</code></pre>
<p>完成配置后，重启Elasticsearch进程即可。后进行内置用户认证密码的设置，在某一台集群节点中，进入进程文件路径，执行如下命令：</p>
<pre><code class="language-shell">bin/elasticsearch-setup-passwords interactive;
</code></pre>
<p>这里给Elasticsearch中内置用户创建密码，其内置用户有：</p>
<ul>
<li>elastic：拥有 superuser 角色，是内置的超级用户，它可以做任何事情。</li>
<li>kibana：拥有 kibana_system 角色，是Kibana用来连接Elasticsearch并与之通信的。Kibana服务器以该用户身份提交请求以访问集群监视API和.kibana索引不能访问 index。</li>
<li>logstash_system：拥有logstash_system角色。是Logstash在Elasticsearch中存储监控信息时使用。</li>
<li>beats_system：拥有 beats_system 角色。是Beats在Elasticsearch中存储监控信息时使用。</li>
<li>apm_system：APM服务器在Elasticsearch中存储监视信息时使用的用户。</li>
<li>remote_monitoring_user：Metricbeat用户在Elasticsearch中收集和存储监视信息时使用。 它具有remote_monitoring_agent和remote_monitoring_collector内置角色。</li>
</ul>
<p>完成此步设置，再使用HTTP/HTTPS协议通过<code>9200</code>端口访问时，就需要帐密了。输入帐密即可访问。<code>curl</code>也可，命令测试示例如下，例如用户名为<code>elastic</code>，密码为<code>ESabc+2333</code>：</p>
<pre><code class="language-shell">curl -uelastic:ESabc+2333 -XGET http://node-1:9200/_cluster/health?pretty
</code></pre>
<h2><a id="kibana%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kibana的部署与配置</h2>
<p>Kibana的部署配置比较简单，安装方式类似Elasticsearch，具体可自行选择，本节不再赘述，使用方法二，执行如下命令，进行安装：</p>
<pre><code class="language-shell">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.8.0-x86_64.rpm;
shasum -a 512 kibana-7.8.0-x86_64.rpm;
rpm --install kibana-7.8.0-x86_64.rpm;
</code></pre>
<blockquote>
<p>**注意：**若<code>shasum</code>提示找不到命令，请输入<code>yum -y install perl-Digest-SHA</code>进行依赖安装。</p>
</blockquote>
<!-- -->
<blockquote>
<p>**提示：**鉴于Elastic网站为国外，下载速度极慢，可选择国内镜像地址，例如华为云的镜像，下载地址：<a href="https://mirrors.huaweicloud.com/kibana/7.8.0/">https://mirrors.huaweicloud.com/kibana/7.8.0/</a></p>
</blockquote>
<p>按上述方式安装后其进程文件路径在<code>/usr/share/kibana</code>，配置文件路径在<code>/etc/kibana</code>。</p>
<p>修改<code>/etc/kibana/kibana.yml</code>文件为如下配置：</p>
<pre><code class="language-yaml">server.port: 5601
server.host: &quot;0.0.0.0&quot;
# 设置Elasticsearch集群地址，方便Kibana做容灾管理
elasticsearch.hosts: [&quot;https://node-1:9200&quot;,&quot;https://node-2:9200&quot;,&quot;https://node-3:9200&quot;]
kibana.index: &quot;.kibana&quot;
# 国际化设置，设置为中文
i18n.locale: &quot;zh-CN&quot;
# 开启X-Pack的安全认证
xpack.security.enabled: true
# Elasticsearch内置账户密码
elasticsearch.username: &quot;kibana&quot;
elasticsearch.password: &quot;ESabc+2333&quot; # 设置内置账户密码时kibana账户的密码
# Kibana SSL/TLS访问开启，若无需配置SSL/TLS，可忽略
server.ssl.enabled: true
server.ssl.key: /etc/kibana/kibana-certificates.key
server.ssl.certificate: /etc/kibana/kibana-certificates.cer
server.ssl.certificateAuthorities: /etc/kibana/kibana-certificates-ca.cer
server.ssl.clientAuthentication: none
# Elasticsearch如开启SSL/TLS访问，则需要配置如下两条规则
elasticsearch.ssl.verificationMode: certificate
elasticsearch.ssl.certificateAuthorities: /etc/kibana/kibana-certificates-ca.cer
</code></pre>
<p>上述Kibana配置中SSL/TLS的认证有点小插曲需要说明，由于Kibana现在不支持<code>.p12</code>文件的加密认证方式，若目前没有SSL/TLS安全机构认可的签发证书，但仍需要启用SSL/TLS，此时需要我们将<code>.p12</code>文件转换后使用配置。具体操作如下：</p>
<pre><code class="language-shell">openssl pkcs12 -in elastic-certificates.p12 -nocerts -nodes &gt; kibana-certificates.key
openssl pkcs12 -in elastic-certificates.p12 -clcerts -nokeys &gt; kibana-certificates.cer
openssl pkcs12 -in elastic-certificates.p12 -cacerts -nokeys -chain &gt; kibana-certificates-ca.cer
</code></pre>
<p>将生成的几个文件放置在合适的路径，例如上述配置将这几个文件放置在了<code>/etc/kibana/</code>路径下，后调用即可。</p>
<blockquote>
<p>**注意：**仍然建议使用域名向安全机构申请认可的签发证书后配置Kibana的SSL/TLS选项，因为自签发证书浏览器不认为是安全的，仍有安全风险，请注意。</p>
</blockquote>
<p>完成配置后即可启动，可通过<code>systemctl</code>命令进行启停：</p>
<pre><code class="language-shell">systemctl start kibana;
systemctl stop kibana;
systemctl restart kibana;
</code></pre>
<p>如需开启开机自启，可通过如下命令开启：</p>
<pre><code class="language-shell">systemctl daemon-reload;
systemctl enable kibana;
</code></pre>
<p>启动后通过浏览器访问即可，可通过输入内置用户访问Kibana，例如用户名为<code>elastic</code>，密码为<code>ESabc+2333</code>：</p>
<p><img src="media/15950655748460/2020-7-18-001.png" alt="Kibana登录界面" /></p>
<p><img src="media/15950655748460/2020-7-18-011.png" alt="Kibana登录后界面" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决CentOS在执行yum命令时报错"Error: rpmdb open failed"]]></title>
    <link href="https://zning.me/15946461550517.html"/>
    <updated>2020-07-13T21:15:55+08:00</updated>
    <id>https://zning.me/15946461550517.html</id>
    <content type="html"><![CDATA[
<p>今天在日常进行CentOS操作的时候，不知为何<code>yum -y install xxx</code>命令突然卡死不动，<code>Ctrl+C</code>取消执行也无解，遂关闭SSH重新建立连接，然而再次重新执行<code>yum -y install xxx</code>命令时却报如下错误：</p>
<span id="more"></span><!-- more -->
<pre><code class="language-shell">...
root@localhost:~&gt;yum -y install xxx
Loaded plugins: fastestmirror, langpacks
Existing lock /var/run/yum.pid: another copy is running as pid 27970.
Another app is currently holding the yum lock; waiting for it to exit...
  The other application is: yum
    Memory :  43 M RSS (362 MB VSZ)
    Started: Mon Jul 13 18:27:38 2020 - 03:46 ago
    State  : Uninterruptible, pid: 27970
Another app is currently holding the yum lock; waiting for it to exit...
  The other application is: yum
    Memory :  43 M RSS (362 MB VSZ)
    Started: Mon Jul 13 18:27:38 2020 - 03:48 ago
    State  : Uninterruptible, pid: 27970
...
</code></pre>
<p>初步判断应该是进程号为<code>27970</code>的那个假死了，即使刚才SSH关闭了也并没有杀掉他，遂干脆利落的执行了<code>kill -9 27970</code>直接杀死，后再执行<code>yum -y install xxx</code>命令，结果又有报错：</p>
<pre><code class="language-shell">...
root@localhost:~&gt;yum -y install xxx
error: rpmdb: BDB0113 Thread/process 27970/140274709284672 failed: BDB1507 Thread died in Berkeley DB library
error: db5 error(-30973) from dbenv-&gt;failchk: BDB0087 DB_RUNRECOVERY: Fatal error, run database recovery
error: cannot open Packages index using db5 -  (-30973)
error: cannot open Packages database in /var/lib/rpm
CRITICAL:yum.main:

Error: rpmdb open failed
...
</code></pre>
<p>哦豁，凉了，rpmdb本地数据存储文件炸了……不过好在有解决方法。</p>
<p>执行如下命令，清理YUM仓库本地数据存储文件：</p>
<pre><code class="language-shell">mv /var/lib/rpm/__db* /tmp;
</code></pre>
<p>执行如下命令，清理yum缓存：</p>
<pre><code class="language-shell">rpm --rebuilddb;
yum clean all
</code></pre>
<p>大功告成。</p>
<p>现在细想一下，yum当时有可能是因为网络问题假死，可能再等等就好了，不过毕竟当时有点着急，以后得注意下。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《架构即未来》之可扩展性组织的人员配置（下一）]]></title>
    <link href="https://zning.me/15945523435332.html"/>
    <updated>2020-07-12T19:12:23+08:00</updated>
    <id>https://zning.me/15945523435332.html</id>
    <content type="html"><![CDATA[
<p>从去年夏末至今，我一直在阅读《架构即未来：现代企业可扩展的Web架构、流程和组织（原书第二版）》这本书。全书阐述了经过验证的信息技术扩展方法，对需要掌握的产品和服务的平滑扩展做了详尽的论述。具有一定的参考价值。从今天起，我将逐步总结之前所看内容，以飨读者，也以便自己回顾。文章既有摘转录，又有自我理解批注。</p>
<p>本文是该书的第一部分的下半部分，是书中的第五章，主要介绍了管理的相关内容，涉及了项目任务管理、团队建设、度量与目标树等部分。</p>
<span id="more"></span><!-- more -->
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%A1%E7%90%86">什么是管理</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86">项目和任务管理</a></li>
<li><a href="#%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE%EF%BC%9A%E7%90%83%E9%98%9F%E7%B1%BB%E6%AF%94">团队建设：球队类比</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%9B%A2%E9%98%9F%EF%BC%9A%E8%8A%B1%E5%9B%AD%E7%B1%BB%E6%AF%94">优化团队：花园类比</a></li>
<li><a href="#%E5%BA%A6%E9%87%8F%E3%80%81%E6%8C%87%E6%A0%87%E5%92%8C%E7%9B%AE%E6%A0%87%E8%AF%84%E4%BC%B0">度量、指标和目标评估</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87%E6%A0%91">目标树</a></li>
<li><a href="#%E4%B8%BA%E6%88%90%E5%8A%9F%E9%93%BA%E8%B7%AF">为成功铺路</a></li>
</ul>

<p>管理是有关执行和实现组织目标、愿景和使命必需的所有活动。它是“以明智和合乎道德的手段来完成任务”。要在管理上成功，。为一个奋发向上的领导，需要专注和致力于学习和成长。也需要安排好任务、人和度量以实现预期的目标。并有如下的特点：</p>
<ul>
<li>项目和任务管理是成功管理的关键。</li>
<li>人力资源管理与组织及其雇用、解雇、培养和发展相关。</li>
<li>度量是管理成功的关键。</li>
<li>管理者需要帮助团队完成任务。</li>
</ul>
<p>经验告诉我们，在每个成功的故事里，最为核心的是在关键的时刻，领导、经理和团队能否在挑战和机遇的面前崛起并使公司获益。“我们确实需要改变目前的方式，来适应新的世界秩序，软件和硬件是开发服务的原材料。我们需要重新思考机构、流程、激励和项目管理。”</p>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是管理</h2>
<p>《韦氏词典》中对管理是这样定义的，“执行或者监督某些事情”或“以执法手段完成某件事情”。对这一定义，我们将略加修改，融入道德因素，更新后的定义是“以明智和合乎道德的手段来完成任务”。</p>
<p>一般来说，雇员有权知道他的表现如何，其不知道真实表现是对股东和员工的不道德行为。使命完成的方式与使命的实际完成一样至关重要。</p>
<p>管理和领导有许多区别，但两者都很重要。如果领导是承诺，那么管理就是行动。如果领导是目的地，那么管理就是方向。如果领导是激励，那么管理就是动机。如果领导是拉力，那么管理就是推力。对于成功的最大化股东财富，需要两者兼备。</p>
<p>管理包括度量活动、目标评估、指标制订。也包括人员配备中的人事责任、人事评估和团队建设（包括技能和其他的特性）。最后，管理包括项目管理中的所有活动，例如驱动团队完成任务，设定有挑战性的项目进度等等。</p>
<blockquote>
<p><strong>好的经理需要具备什么素质</strong></p>
</blockquote>
<blockquote>
<p>从领导的角度看，管理是一个有几个参数的函数，其中有些参数也适用于领导函数。</p>
<p>最好的经理在看到细节的同时，又能令人难以置信地面向目标和任务。一旦分配到一个任务或目标，他们就能把任务或目标分解。这个分解的活动不仅涉及行动，也包括沟通、组织结构、合理的薪酬后勤和资金等。</p>
<p>好的经理练就了一身管理人的技能，这有助于他们把组织内每个人的最大潜力都发掘出来。</p>
<p>最后，即使最好的经理也承认自己需要不断地提高，而能够意识到提高的唯一办法是度量。</p>
</blockquote>
<h2><a id="%E9%A1%B9%E7%9B%AE%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目和任务管理</h2>
<p>好的经理在预算内按时完成项目，并且符合为股东创造价值的预期。优秀的经理，甚至能在面对逆境的时候亦能如此。但是，理解如何成功地完成那些项目所需要采取的行动也非常重要。</p>
<p>普鲁士名将赫尔穆特·冯·毛奇有句非常出名的话，“没有万全的作战计划”。这句话对管理复杂产品的研发尤为正确。</p>
<p>经验告诉我们，虽然项目计划很重要，但是创造价值的部分却不是最初的计划，而是在过程中对项目及其可能路径的深入思考。不幸的是，太多人把原来制订的计划看成是通往成功的唯一路径，而不是众多可能路径中的一个。毛奇的这句话警示我们要把关注点从最初计划的执行，转移到具有重要价值的应急上。与其像激光一样聚焦在计划的精密性上，我们更应该考虑选择哪条路径以取得项目的成功。因此，在AKF我们实践了5-95规则：即用5%的时间制订一个充足、保守和详细的计划，同时承认这个计划不是完备的，把其余95%的时间投入到应急演练，以应付突发事件。</p>
<p>项目计划的价值是在思考的过程中理解可能的执行选项，从而更好地为股东创造价值。</p>
<h2><a id="%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE%EF%BC%9A%E7%90%83%E9%98%9F%E7%B1%BB%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>团队建设：球队类比</h2>
<p>在成本可控的前提下，为了确保最大的产出和最高的质量，我们必须不断地寻找负担得起的最好的人才。大多数人并不积极地管理技能、人员和团队的组成，其结果相当于欺骗公司和股东。</p>
<p>组织的产出取决于个人的产出和团队的规模。效率是高性价比可扩展性的一个组成部分，用来度量以同样的投入取得更多或更好的产出，或者以较少的投入取得更多的产出。人的扩展性是与个人、规模和组织相关联的。</p>
<p>记住，不做某事的决定意味着你决定了做某事。此外，忽略了一些应该做的事情其实等同于决定不去做。如果你没有花几周的时间与团队的成员们相处，那相当于你已经决定不花时间与他们相处。这是绝对不可原谅的，而且当与董事会讨论这些问题的时候，你的感觉可能也不会太好。</p>
<h2><a id="%E4%BC%98%E5%8C%96%E5%9B%A2%E9%98%9F%EF%BC%9A%E8%8A%B1%E5%9B%AD%E7%B1%BB%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化团队：花园类比</h2>
<p>组织的扩展在很大程度上依赖于人才，而这又取决于人均产出及在企业文化影响下行为的一致性。花园应该是经过精心设计的，团队也同样如此。设计团队意味着要找到符合组织愿景和使命所需要的合适人才。</p>
<p>在快速增长的公司里，管理者通常会花很多时间来面试和挑选候选人，但通常花在每个候选人身上的时间却很少。更糟的是，这些管理者通常不会花时间去分析和总结以往招聘决策的好坏。要为某个特定的岗位找到合适的人，需要重视和纠正过去招聘中的失败，复制以往招聘中的成功。然而，在面试中常常只关注技能，而忽略其他更重要的方面，如企业文化的适应性及团队的配合度。自问：为什么你要舍弃某人?为什么有人决定要离开?</p>
<p>要从生产力和质量的角度来考虑组织的人员需求。同时鼓励尽可能花更多的时间与候选人互动，力争第一次就找到合适的人。</p>
<p>照顾花园与优化团队异曲同工。所有与管理团队相关的事情，常常因为时间不足而被忽略。我们可能会花工夫来摘新花，但是却时常忘记，花园里那些已经盛开的花朵也同样需要滋养。</p>
<p>培养的目的是让团队成员成长，以满足股东的期望。这包括指导、赞扬、正确地掌握技术或方法、调整薪酬和股权以及任何使员工更强大和更优秀的办法。</p>
<p>好的团队喜欢积极的、可以实现的挑战。</p>
<p>类比管理花园，营养就是你用在指导表现不佳的个人使其达到可以接受的表现水平的时间，是团队花在补偿表现差的个人所造成的不良结果的时间。对大多数执行人员和管理者来说，给花园除草是最痛苦的活动，因此，这往往是我们最后的手段。</p>
<p>虽然你必须遵守公司淘汰员工的有关要求，但是想办法尽快淘汰妨碍大家实现目标的人极为重要。越早淘汰这些表现差的人，就能越快找到合适的替代者，让团队向前发展。</p>
<p>当一个员工制造出充满敌意的工作环境时，这种情况会更加明显。长期的实践让我们领悟到，对表现差的人要尽早淘汰。</p>
<h2><a id="%E5%BA%A6%E9%87%8F%E3%80%81%E6%8C%87%E6%A0%87%E5%92%8C%E7%9B%AE%E6%A0%87%E8%AF%84%E4%BC%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>度量、指标和目标评估</h2>
<p>我们确信要营造一种企业文化，支持度量任何与创造股东价值相关联的活动。通常我们建议度量成本、可用性、响应时间、生产率以及质量。</p>
<p>成本直接影响平台的扩展性。无疑，公司的工程计划预算，如果不是有人发给你，就是你自己制订。理想的情况是，一个成长型公司有专门的部分预算用在平台或服务的扩展上。这个百分比就是一个有趣的、需要跟踪度量的指标。</p>
<p>我们建议以工程总支出的百分比和每笔交易的花费，作为度量扩展的成本。而对采用相对成本还是绝对成本来度量和报告可扩展性的成本存在着争议。因此，与其只报告扩展的绝对成本，在位股东创造价值的基础上，将这种价值规范化。</p>
<p>当要寻找度量的目标时，可用性是一个必不可少的选择。报告宕机时间中有多少与平台或系统的可扩展性问题相关联。目的是彻底消除因为用户无法完成交易而丧失业务机会的现象。</p>
<p>与可用性密切相关的是响应时间。即使没有服务水平协议（SLA），响应时间的度量应该和服务水平协议互相对照比较。在理想的情况下，响应时间所涉及的用户交易，应该是与实际的终端，而不是代理之间的互动。对关键的交易，除了绝对度量内部或外部服务水平以外，还应该包括跟踪月度环比的相对度量。假如收入和放弃率与某个关键交易的响应时间变长紧密相关，这些数据可以解释可扩展性项目的作用。</p>
<p>生产效率是另外一个重要的度量指标。在考虑如何度量生产效率的时候，真正的诀窍是把它分成至少两个部分。第一部分讨论工程团队是否用尽可能多的时间来解决工程相关的任务。第二部分的重点是度量每个工作日的产出。</p>
<p>质量不在可扩展性管理的度量范围之内。显然需要了解像错误数量这样的典型指标，生产系统和版本发布中的KLOC量，整个产品中错误的数量和产品质量工作的成本，我们建议围绕着影响可扩展性，把这些因素进一步分解。</p>
<h2><a id="%E7%9B%AE%E6%A0%87%E6%A0%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目标树</h2>
<p>目标树的根是一个或者多个公司或组织的大目标，将其分解成次级的目标，通过达成这些次级目标进而实现大目标。</p>
<p>质量和可用性都会影响产品变现的机会。</p>
<h2><a id="%E4%B8%BA%E6%88%90%E5%8A%9F%E9%93%BA%E8%B7%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为成功铺路</h2>
<p>到目前为止，我们描绘了一张经理的画像，他同时是工头、战术家、园丁和测量师，还不止这些。除了负责确保团队完成工作外，还要决定选择哪条路径，达成什么目标以及如何度量工作的进展，经理必须要确保已经用推土机把通往目标的路径推平铺好。</p>
<p>我们的意思只是管理者负责为组织扫清通往目标成功道路上的障碍。人们很容易把这种想法和“任何挡在路上的都是阻碍成功的障碍，必须移除”混淆起来。有时，路上的障碍起着确保你表现正常的作用。真正的障碍是出了问题，但没有处理。</p>
<p>当你遇到这些障碍时，记住这个团队不是为你工作，而是与你一起工作你可能是团队的负责人，但也是团队成功的关键部分。好的管理者实际上会亲自上手，帮助团队完成目标。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“源产控”系列（二）在CentOS 8上使用Nginx 1.18: 编译安装与基本使用]]></title>
    <link href="https://zning.me/15941166309027.html"/>
    <updated>2020-07-07T18:10:30+08:00</updated>
    <id>https://zning.me/15941166309027.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本篇为慧响技术角“源产控”专题系列第2篇文章。</p>
</blockquote>
<!-- -->
<blockquote>
<p>慧响技术角“源产控”专题，将聚焦开源、国产化、自主可控三个方向的技术，以操作系统、中间件、数据库、程序应用等为粗分类，更新相关技术的发展趋势、探究技术核心的深度使用、系统总结技术整体架构，为对相关技术的学习者提供可观的资料，亦为个人同步学习总结的笔记，以飨读者。</p>
</blockquote>
<p>本篇对在CentOS 8上使用Nginx 1.18的基本安装与基本使用进行介绍与总结，未来对在CentOS 8上使用Nginx 1.18的相关，将陆续更新其使用总结、性能调优等方面的系列文章，敬请期待。</p>
<span id="more"></span><!-- more -->
<ul>
<li><a href="#nginx%E6%98%AF%E4%B8%AA%E5%95%A5">Nginx是个啥</a></li>
<li><a href="#%E5%9C%A8centos-8%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85nginx-1-18">在CentOS 8进行安装Nginx 1.18</a></li>
<li><a href="#%E5%9C%A8centos-8%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8nginx-1-18">在CentOS 8初步使用Nginx 1.18</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>

<h2><a id="nginx%E6%98%AF%E4%B8%AA%E5%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nginx是个啥</h2>
<p>Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。该软件由伊戈尔·赛索耶夫创建并于2004年首次公开发布。2011年成立同名公司以提供支持。2019年3月11日，Nginx公司被F5 Networks以6.7亿美元收购。Nginx是免费的开源软件，根据类BSD许可证的条款发布。一大部分Web服务器使用Nginx，通常作为负载均衡器。</p>
<p>其开源版本官网是nginx.org。商业版本官网是nginx.com。</p>
<p>不过说起来Nginx，就不得不提在Nginx被F5收购后Nginx作者被捕的事儿了。据外媒报道，2019年12月12日，俄罗斯警方搜查了商业服务器公司Nginx，并当场带走了两位联合创始人。。关于这个事儿，我在文章《战疫之下，哪些事可能会改变我们》也拿其为例对个人品牌与口碑塑造的一些风险进行了阐述。有兴趣的可以点进去看一看。</p>
<p>对于Nginx，由于其发展迅速、性能卓越、开源开放，收割了很多Web服务提供与负载均衡、反向代理场景的市场，也衍生了很优秀的二次开发版本例如国人开发的OpenResty、阿里开源的Tengine等。在“在CentOS 8上使用Nginx 1.18”系列后面将择机对两个优秀的二次开发进行介绍。</p>
<h2><a id="%E5%9C%A8centos-8%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85nginx-1-18" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在CentOS 8进行安装Nginx 1.18</h2>
<p>虽然我们可以通过<code>yum -y install nginx</code>进行安装，但是在“源产库”系列第一篇文章《CentOS 8之初相识》中有过介绍，其镜像源预编译的版本为1.14，而截至文章发表之日Nginx的稳定版本已更新到了1.18，主线版本更新到了1.19，因此我们使用官网的稳定源码版本进行下载编译。</p>
<p><img src="media/15941166309027/15941181736377.jpg" alt="" style="width:1036px;" /></p>
<blockquote>
<p>Nginx版本下载页，截至发文（2020-07-07）稳定版本已更新到了1.18，主线版本更新到了1.19</p>
</blockquote>
<!-- -->
<blockquote>
<p>小知识：关于稳定版本和主线版本。前者是Nginx更新接收针对高严重性错误的修复，但不会使用最新的功能，其版本号的第二位用偶数表示。而后者是Nginx是更新活跃的开发分支，其添加了最新功能和错误修复，其版本号的第二位用奇数表示。不过在Nginx中，“稳定”指的是功能和更新频率，它与软件质量无关。稳定分支在其生命周期中从不接收新功能，并且通常仅接收一个或两个更新，用于修复严重的错误。 稳定分支的生命周期一般是一年，每年四月官方就会停止对当前稳定分支的维护，不再提供错误修复补丁。</p>
</blockquote>
<p>下载并解压<code>nginx-1.18.0.tar.gz</code>：</p>
<pre><code class="language-shell">wget http://nginx.org/download/nginx-1.18.0.tar.gz;
tar -zxvf nginx-1.18.0.tar.gz;
</code></pre>
<p>进入目录<code>cd nginx-1.18.0</code>，目录结构如下：</p>
<pre><code class="language-shell">总用量 1204
drwxr-xr-x 6 1001 1001    326 7月   7 18:50 auto
-rw-r--r-- 1 1001 1001 302863 4月  21 22:09 CHANGES
-rw-r--r-- 1 1001 1001 462213 4月  21 22:09 CHANGES.ru
drwxr-xr-x 2 1001 1001    168 7月   7 18:50 conf
-rwxr-xr-x 1 1001 1001   2502 4月  21 22:09 configure
drwxr-xr-x 4 1001 1001     72 7月   7 18:50 contrib
drwxr-xr-x 2 1001 1001     40 7月   7 18:50 html
-rw-r--r-- 1 1001 1001   1397 4月  21 22:09 LICENSE
drwxr-xr-x 2 1001 1001     21 7月   7 18:50 man
-rw-r--r-- 1 1001 1001     49 4月  21 22:09 README
drwxr-xr-x 9 1001 1001     91 7月   7 18:50 src
</code></pre>
<p><code>conf</code>文件夹内为Nginx的初始配置文件，<code>contrib</code>文件夹放置了三位开源贡献者贡献的三个插件内容，<code>html</code>文件夹为默认站点文件内容，<code>src</code>文件夹为Nginx源码。<code>configure</code>文件为编译的配置文件。</p>
<p>拷贝Nginx安装包内如下文件到路径，可以让vim对<code>nginx.conf</code>的语言语法进行高亮解析：</p>
<pre><code class="language-shell">cp -r contrib/vim/* ~/.vim/;
</code></pre>
<p><code>./configure --help</code>可以查看Nginx编译支持参数列表，<code>configure</code>文件进行设置后，会在<code>objs</code>文件内生成Nginx的安装所需文件，其中<code>ngx_modules.c</code>，该文件决定接下来编译有哪些模块需要编译进Nginx。</p>
<p>本文不涉及模块的编译使用，我们使用最简单的编译设置进行编译安装：</p>
<pre><code class="language-shell">./configure --prefix=/usr/local/nginx;
</code></pre>
<p>如果报如下错误，请执行命令<code>yum -y install pcre-devel openssl openssl-devel</code>进行安装：</p>
<pre><code class="language-shell">...
checking for PCRE library ... not found
checking for PCRE library in /usr/local/ ... not found
checking for PCRE library in /usr/include/pcre/ ... not found
checking for PCRE library in /usr/pkg/ ... not found
checking for PCRE library in /opt/local/ ... not found

./configure: error: the HTTP rewrite module requires the PCRE library.
You can either disable the module by using --without-http_rewrite_module
option, or install the PCRE library into the system, or build the PCRE library
statically from the source with nginx by using --with-pcre=&lt;path&gt; option.
</code></pre>
<p>出现以下内容，即为<code>configure</code>文件设置完成：</p>
<pre><code class="language-shell">Configuration summary
  + using system PCRE library
  + OpenSSL library is not used
  + using system zlib library

  nginx path prefix: &quot;/usr/local/nginx/&quot;
  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;
  nginx modules path: &quot;/usr/local/nginx/modules&quot;
  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;
  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;
  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;
  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;
  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;
  nginx http client request body temporary files: &quot;client_body_temp&quot;
  nginx http proxy temporary files: &quot;proxy_temp&quot;
  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;
  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;
  nginx http scgi temporary files: &quot;scgi_temp&quot;
</code></pre>
<p>紧接着执行<code>make</code>命令，执行后，在<code>objs</code>文件夹下可以看到编译后的<code>nginx</code>二进制文件和目标文件。无报错说明正常。如若首次安装Nginx，紧接着执行<code>make install</code>安装即可。如果是进行Nginx升级，<code>make install</code>是不应该用的，需要做的是将该目录下生成的<code>nginx</code>二进制文件拷贝到已有Nginx的二进制文件相应目录中。</p>
<h2><a id="%E5%9C%A8centos-8%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8nginx-1-18" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在CentOS 8初步使用Nginx 1.18</h2>
<p>安装完成，输入如下命令进行启动Nginx：</p>
<pre><code class="language-shell">/usr/local/nginx/sbin/nginx;
</code></pre>
<p>Nginx基本指令格式为<code>nginx -s reload</code>，具体指令解释如下：</p>
<ul>
<li><code>nginx -?/-h</code>为显示帮助信息；</li>
<li><code>nginx  -c</code>为使用指定的配置文件，后跟配置文件路径；</li>
<li><code>nginx -g</code>为指定配置指令，后跟需要指定的配置指令；</li>
<li><code>nginx-p</code>为指定运行目录，后跟运行目录路径；</li>
<li><code>nginx -s</code>发送信号，其中后跟参数<code>stop</code>为立即停止服务、<code>quit</code>为有序停止服务；<code>reload</code>为重载配置文件、<code>reopen</code>为重新开始记录日志文件；</li>
<li><code>nginx -t/-T</code>测试配置文件是否有语法错误；</li>
<li><code>nginx -v、nginx -V</code>打印Nginx的版本信息或编译信息。</li>
</ul>
<p>在浏览器访问IP，如图，可以访问即正常。</p>
<p><img src="media/15941166309027/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-07-07%2019.25.48.png" alt="屏幕截图 2020-07-07 19.25.48" /></p>
<p><code>ps -ef | grep nginx</code>查看进程情况：</p>
<pre><code class="language-shell">root      8556     1  0 19:24 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx
nobody    8557  8556  0 19:24 ?        00:00:00 nginx: worker process
root      8561  8702  0 19:25 pts/0    00:00:00 grep --color=auto nginx
</code></pre>
<p>现在安装好的基本Nginx，完整的<code>nginx.conf</code>文件如下：</p>
<pre><code class="language-conf">#user  nobody;
worker_processes  auto;

error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  logs/access.log  main;

    server {
        listen       80;
        server_name  localhost;

        access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
</code></pre>
<p>Nginx配置语法有如下的规则：</p>
<ol>
<li>日志文件由指令与指令块构成；</li>
<li>每条指令以<code>;</code>结尾，指令与参数间以空格符号分隔；</li>
<li>指令块以<code>{}</code>将多条指令组织在一起；</li>
<li><code>include</code>语句允许组合多个配置文件以提升可维护性；</li>
<li>使用<code>#</code>添加注释，提高可读性；</li>
<li>使用<code>$</code>可调用变量；</li>
<li>部分指令的参数支持正则表达式。</li>
</ol>
<p>Nginx有多种指令块，其中<code>http</code>块表示此为HTTP协议处理块、<code>upstream</code>表示有上游服务提供的配置信息、<code>location</code>对应URL的表达式、<code>server</code>对应一个或一组域/域名的访问。</p>
<p>以下是配置文件部分的参数解释:</p>
<ul>
<li><code>worker_processes</code>为设定工作进程数，若设置为<code>auto</code>则Nginx将根据机器的内核数进行设定分配，如无特殊需求一般建议设置为<code>auto</code>。</li>
<li><code>error_log</code>设定错误日志的路径与等级，其中等级有<code>debug</code>, <code>info</code>, <code>notice</code>, <code>warn</code>, <code>error</code>, <code>crit</code>, <code>alert</code>, <code>emerg</code>几种，以严重性从高到低的顺序列出。根据官方文档的解释，设定某个级别的意义是该级别及以上的日志会被打印在日志文件中，例如设置<code>info</code>则包括其本身在内以及<code>notice</code>, <code>warn</code>, <code>error</code>, <code>crit</code>, <code>alert</code>, <code>emerg</code>都会被列出。若第二个字段为空，默认为<code>error</code>。</li>
<li><code>log_format main 'XXX'</code>设定日志格式，<code>main</code>标示为命名，在遇到对不同域名进行不同格式的命名记录时需要用到，<code>server</code>区块下<code>access_log logs/access.log main;</code>可以以main格式进行记录。</li>
</ul>
<p>关于其他参数例如<code>pid</code>、<code>worker_connections</code>等，以及<code>server</code>、<code>upstream</code>、<code>location</code>指令块，将在后续的“在CentOS 8上使用Nginx 1.18”系列文章中陆续介绍与展示使用方法。</p>
<h2><a id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考资料</h2>
<ol>
<li><a href="oschina.net/news/106928/nginx-1-16-1-17-released">nginx 主线版 1.17.0 发布，1.14 稳定分支已停止维护</a></li>
<li><a href="nginx.org">Index - nginx.org</a></li>
<li><a href="http://nginx.org/en/docs/ngx_core_module.html#error_log">Core functionality - nginx.org</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《架构即未来》之可扩展性组织的人员配置（中二）]]></title>
    <link href="https://zning.me/15939493033756.html"/>
    <updated>2020-07-05T19:41:43+08:00</updated>
    <id>https://zning.me/15939493033756.html</id>
    <content type="html"><![CDATA[
<p>从去年夏末至今，我一直在阅读《架构即未来：现代企业可扩展的Web架构、流程和组织（原书第二版）》这本书。全书阐述了经过验证的信息技术扩展方法，对需要掌握的产品和服务的平滑扩展做了详尽的论述。具有一定的参考价值。从今天起，我将逐步总结之前所看内容，以飨读者，也以便自己回顾。文章既有摘转录，又有自我理解批注。</p>
<p>本文是该书的第一部分的中间部分，是书中的第四章，主要介绍了领导力相关的概念、模型、理念、成功因果路线图等部分。</p>
<span id="more"></span><!-- more -->
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%AF%BC%E5%8A%9B">什么是领导力</a></li>
<li><a href="#%E9%A2%86%E5%AF%BC%E5%8A%9B%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">领导力概念模型</a>
<ul>
<li><a href="#%E4%BB%A5%E8%BA%AB%E4%BD%9C%E5%88%99">以身作则</a></li>
<li><a href="#%E4%B8%8D%E5%88%9A%E6%84%8E%E8%87%AA%E7%94%A8">不刚愎自用</a></li>
<li><a href="#%E4%BB%A5%E4%BA%BA%E4%B8%BA%E6%9C%AC%EF%BC%8C%E4%BD%BF%E5%91%BD%E4%B8%BA%E5%85%88">以人为本，使命为先</a></li>
<li><a href="#%E5%86%B3%E7%AD%96%E8%8B%B1%E6%98%8E%EF%BC%8C%E4%BB%A5%E5%BE%B7%E6%9C%8D%E4%BA%BA">决策英明，以德服人</a></li>
<li><a href="#%E7%94%A8%E4%BA%BA%E4%B8%8D%E7%96%91">用人不疑</a></li>
<li><a href="#%E4%B8%8E%E8%82%A1%E4%B8%9C%E4%BB%B7%E5%80%BC%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">与股东价值保持一致</a></li>
<li><a href="#%E5%8F%98%E9%9D%A9%E5%9E%8B%E9%A2%86%E5%AF%BC">变革型领导</a></li>
<li><a href="#%E6%84%BF%E6%99%AF">愿景</a></li>
<li><a href="#%E4%BD%BF%E5%91%BD">使命</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87">目标</a></li>
</ul>
</li>
<li><a href="#%E6%88%90%E5%8A%9F%E7%9A%84%E5%9B%A0%E6%9E%9C%E8%B7%AF%E7%BA%BF%E5%9B%BE">成功的因果路线图</a></li>
</ul>

<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%AF%BC%E5%8A%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是领导力</h2>
<p>本书把领导力定义为“影响一个组织或者个人达成某个特定目标的行为的力量”，即对组织或个人完成具体目标的影响力。</p>
<p>领导不仅仅指个人或组织的直接报告人。你可以领导你的同伴、来自于其他机构的人，甚至管理层。一个组织内的榜样或楷模也是领导。你会看到，领导是关于你做什么和如何影响你周围其他人或好或坏的行为。</p>
<p>而领导的失败是无法扩展的最常见原因。经常有公司只聚焦在产品功能的研发上，没有意识到在客户的不断要求下，要达到合适的系统可用时间和响应速度需要做什么事情。</p>
<p>【领导：天生的还是人造的】一个人的领导能力是直接取决于其影响个人或组织行为的能力。影响行为的能力来自于几个方面，有些是天生的品质，有些是环境熏陶的结果，还有些是日久形成的容易修改的工具和方法。但是经常发生的是，好的外表被当成是最重要的，但是铁的事实是大多数人都愿意围着长相好看的人转。</p>
<p>我们相信，人的性格是天生的，这些因素可能不仅是由基因决定的，还由环境养成的。事实上，长相、感召力、仪表、魅力和人格只是许多领导因素中的一部分，尽管这些因素有所帮助，其他的因素在形成领导的影响力方面同样重要。</p>
<h2><a id="%E9%A2%86%E5%AF%BC%E5%8A%9B%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领导力概念模型</h2>
<p>我们相信领导的能力，或者说影响一个人或组织的相关目标的行为，是关于几个特性的函数。我们把这些特性叫做函数的参数。输入参数到领导力函数后，会返回一个结果，这个结果就可以反映出个人有效地改变和影响行为的能力。</p>
<p>领导力函数的有些参数，与你能否通过创新或者凭毅力做出什么事情有关系。在这里，创新指的是随口说出愿景的能力，而毅力是不断地花时间进行尝试，但产生的效果是一样的。</p>
<p>领导力函数的其他参数与别人如何看待你有关系。这里有两个重点：感觉和感觉的效果对你所领导团队的影响。如果你是位领导，任何时候都会有人在看着你，他们将在你最弱的时候看着你，并据此形成印象。</p>
<p>用函数来描述领导力的且的是要告诉你，尽管可能无法改变一些事情，但是你仍然可以努力来当一个好的领导。</p>
<p>在缺乏经验或者存在高度无知的情况下，对自己能力 的高估最严重。而要从好的领导力中受益，必须清楚地掌握现状。在《和谐领导》(Resonant Leadership)一书中，理查德·伯亚兹和安妮·麦基发现专注、希望和同情是改变个人的三个要素。专注是自知，包违的和能力，希望和回懂有助于产生愿景，从而驱动改变。</p>
<p>最好的选择就是有一个来自于老板、同级和下级的工作表现评议，常用的是360度评议(360-degree review process)。只有那些可以确切地告诉你如何帮助他们改善表现和绩效评议结果的人，才是你要影响的人。而这个过程必须是匿名的。</p>
<p>当然，如果绩效自评结果不能形成改进计划，那就是浪费你和组织的管理时间。我们认为计划应该既包括依赖和发扬优点，也包括克服自己的缺点。没有人因为优点而无法达到目标，也没有人因为缺点而取得成功。关于领导力，我们必须要通过最小化缺点来减少亏损面，通过最大化优点来增加积累面。</p>
<p>最好的领导人所共同拥有的几个特性，包括以身作则、不刚自用、努力完成使命，同时留意和同情组织的需要、及时决策、给团队授权、和股东的利益保持一致。</p>
<h3><a id="%E4%BB%A5%E8%BA%AB%E4%BD%9C%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以身作则</h3>
<p>大多数的人都会赞同，在较好的工作环境或者文化环境里工作的员工，比在相对较差的工作环境或者文化环境里工作的员工的产出要高。</p>
<p>评估你对团队期望的文化标谁，并再次确定自己的行为举止是否与企业文化标准的要求一致。但这并不是说你的团队不能做你没做过的任何事情。从行为的角度来说，你应该表现给你的团队看，已所不欲，勿施于人。</p>
<p>他人对你滥用职权的看法会毁掉你的信用而且影响到领导力函数的结果。破坏领导力的函数会造成员工浪费时间来讨论滥用职收甚至让他们误以为类似的滥用职权是可以接受的行为，这些讨论浪费时间和金钱，减小组织的规模。</p>
<p>每个人都可以通过“以身作则”来提升领导力。严于律己，不徇私枉法，行为的方式应和你期望自己的组织的表现一样。</p>
<h3><a id="%E4%B8%8D%E5%88%9A%E6%84%8E%E8%87%AA%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不刚愎自用</h3>
<p>任何一个公司的任何一个职位都不允许自我意识膨胀。过度自夸的言行与打造最好的团队背道而驰，随着时间的推移将会侵蚀股东的价值。最好的领导在为股东争取利益方面大公无私。你对他最忠心，愿意为他做任何事情，那个老板一定会把股东的利益放在第一位，并且总是强调团队。首先想着如何为股东创造更多的价值，而不是如何为个人带来价值。</p>
<h3><a id="%E4%BB%A5%E4%BA%BA%E4%B8%BA%E6%9C%AC%EF%BC%8C%E4%BD%BF%E5%91%BD%E4%B8%BA%E5%85%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以人为本，使命为先</h3>
<p>能干的领导和经理完成使命，伟大的领导和经理则是通过营造文化氛国，使员工感受到资识和尊重，诚实而且及时地处理绩效相关的反馈。</p>
<p>好的领导会确保那些产生最多价值的人得到最好的奖赏，确保那些表现远在一般人之上的人能够得到应有的休假。</p>
<p>关爱并不意味着要在组织内部实行福利或者终身雇用制度。关爱也并不意味着要去设置容易达成的目标。</p>
<p>检验“以人为本”是较为简单的，对于成功组织内经验丰富的领导，看看他手下有多少人曾经不断地跟随这位经理升迁就能知道。</p>
<p>“以已为本，使命为先”的领导把员工当成向上爬的梯子，踩着他们往上走。“以人为本，使命为先”的领导则为所有的一流员工建立好向上爬的梯子。</p>
<h3><a id="%E5%86%B3%E7%AD%96%E8%8B%B1%E6%98%8E%EF%BC%8C%E4%BB%A5%E5%BE%B7%E6%9C%8D%E4%BA%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>决策英明，以德服人</h3>
<p>一般而言，你要依靠合适的信息，不浪费时间，迅速行动并做出最佳决策。勇敢和决策是一个领导必然要关注的事情。</p>
<p>我们推崇一个信条，“你想让大家做什么，那么就教导什么，你教导什么，你的标准就是什么。”这里面的允许既指其他人也包括你自己。不论大事小情，这一条特别适用于那些违反道义的情况。</p>
<p>什么都不能摧毁你内在的可信性和你对组织的影响能力（甚至包括对不正当行为的理解）。绝不能把说谎、欺骗或偷盗与为股东创造财富相提并论。</p>
<h3><a id="%E7%94%A8%E4%BA%BA%E4%B8%8D%E7%96%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用人不疑</h3>
<p>赋予团队权力，比任何领导力活动或行为对组织扩展能力的影响都大。授权是分配行为、责任和所有权，可能包括把部分或全部领导权和管理权交给个人或组织。以领导力而言，授权是提升个人、团队、领导和经理对其所负责事项的骄傲感。总体看来，相信自己被赋予权力的个人，比那些相信自己仅仅执行命令的个人，在做决策和管理过程中的效率更高。简而言之，真正的授权管理相当于加倍组织的产出，因为其本身不再成为所有活动的瓶颈。</p>
<p>然而，领导可能明确地把权力赋予其他人，但事实上却通过设定一个瓶颈限制着组织的产出。其结果是士气、产出和信任均遭到破坏。另外，赋予个人和团队权力并不是说领导对结果不再负责任。尽管领导可以授权，但是对达成的结果，他却要对股东负责。</p>
<h3><a id="%E4%B8%8E%E8%82%A1%E4%B8%9C%E4%BB%B7%E5%80%BC%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与股东价值保持一致</h3>
<p>简单地说，在一个以营和为目的的公司里，你的工作就是为股东创造财富。更重要的是，你的工作就是要使股东的财富最大化。而如果是在非营利机构，这些是由慈善团体捐助或者别人付钱请你做好事的话，那么更常见的是创造一种情感财富。</p>
<h3><a id="%E5%8F%98%E9%9D%A9%E5%9E%8B%E9%A2%86%E5%AF%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变革型领导</h3>
<p>最有成效的领导往往通过理念来影响其组织，把团队的利益置于个人利益之上，为团队及其成员提供智能激发，为团队成员的福利和职业发展展现出诚实和个性化的关怀。</p>
<p>这些高尚的领导方式是通过理念的影响来实现，常被称为“变革型领导方式。”变革型领导方式的扩展性明显更好。不像交易型关注个人，变革型可以关注团队。从与个人讨论，变成与团队研究如何激励大家来完成任务。</p>
<h3><a id="%E6%84%BF%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>愿景</h3>
<p>总的来说，领导在愿景和使命上面往往没有投入足够的精力。一般情况下，可以在年度计划会议中，安排一到两个小时有关愿景和使命的讨论。这个讨论团队可以选择，但是领导必须参与。</p>
<p>愿景应该是可以度量和验证的。但是在制定愿景的进程中，基于未来状态不是什么去定义最终状态耗时太多。因此，我们建议愿景要简洁地定义理想的终极状态。</p>
<p>展现愿景最简单的方法或许是从如何给一个人发出指令的角度整看。当指令发出时，你会同时说明如何确定目标是否达成。一个愿景应该符合下面这些标准：</p>
<ul>
<li>对理想未来的生动描述</li>
<li>为股东创造价值很重要</li>
<li>可度量</li>
<li>激动人心</li>
<li>结合信仰的因素</li>
<li>大致不变，但可根据需要修改</li>
<li>容易记忆</li>
</ul>
<h3><a id="%E4%BD%BF%E5%91%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使命</h3>
<p>如果愿景是对理想未来或者旅途终点的生动描绘，那么使命就是我们到达目的地的总路线或者行动计划。对使命的描述更亲于公司的现状，因为现状对到达理想状态或公司的愿景极为重要。使命应当包括一些目的，一些今天要做的事情和如何达成愿景的方向同愿景描述一样，使命的描述也应该是可以验证的。使命的描述应该符合下述条件：</p>
<ul>
<li>对当前状态和行动的描述</li>
<li>有目的感</li>
<li>可度量</li>
<li>一个大方向或一条通往愿景的道路</li>
</ul>
<h3><a id="%E7%9B%AE%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目标</h3>
<p>目标就是旅行中确保我们走在正确道路上的路标或者里程碑。我们认为最好的目标是通过SMART来制订的。SMART是：</p>
<ul>
<li>具体(S）</li>
<li>可度量（M）</li>
<li>可达成(但是有挑战性）（A）</li>
<li>现实性(R）</li>
<li>时限性（或包含时间因素）（T）</li>
</ul>
<p>目标不会告诉人们如何做什么事情，但是会指明是否在沿着正确的道路前进。</p>
<h2><a id="%E6%88%90%E5%8A%9F%E7%9A%84%E5%9B%A0%E6%9E%9C%E8%B7%AF%E7%BA%BF%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成功的因果路线图</h2>
<p>作为一个领导，你可以做得最好和最容易的事情之一，是确保组织的成功，让大家理解他们所做的日常贡献怎么对实现组织的愿景起作用，进而为股东创造价值。我们把对这种关系的理解叫做成功的因果路线图。通常比较容易确定这种关系，否则我们就要质疑这一岗位存在的必要性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“源产控”系列（一）CentOS 8之初相识]]></title>
    <link href="https://zning.me/15932531416990.html"/>
    <updated>2020-06-27T18:19:01+08:00</updated>
    <id>https://zning.me/15932531416990.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>**作者按：**当下国内外软件开发领域，开源队伍的壮大趋势随着微软收购Github达到了新的高度，众多业界巨头例如Google、Facebook、IBM、Oracle、亚马逊、腾讯、阿里等亦在开源社区之中贡献着自己的智慧，并且带动了开源理念与风气。而随着开源的蓬勃发展，国产化软件也势头正猛，以阿里云OceanBase为代表的一系列国产化软件，凭借着它们强大的业务背景和一定体量的业务需求锤炼，成为了国产化软件的排头兵，带动了更多行业领域企业加入这股洪流之中。这两股强大的东风之流行，伴随着宏观经济贸易的不确定性，点燃了国民核心行业核心技术“自主可控”的星星之火。开源、国产化、自主可控，三个议题的碰撞会出现怎样的火花？“源产控”专题就在此应运而生。</p>
<p>慧响技术角“源产控”专题，将聚焦开源、国产化、自主可控三个方向的技术，以操作系统、中间件、数据库、程序应用等为粗分类，更新相关技术的发展趋势、探究技术核心的深度使用、系统总结技术整体架构，为对相关技术的学习者提供可观的资料，亦为个人同步学习总结的笔记，以飨读者。</p>
<p>本系列首文，即本文，以近期更新的开源操作系统CentOS 8的介绍为开篇，对CentOS 8进行一些简要的介绍，未来对开源操作系统CentOS 8，将陆续更新其基本使用总结、特性使用总结等方面的系列文章，敬请期待。</p>
</blockquote>
<span id="more"></span><!-- more -->
<ul>
<li><a href="#centos%E6%98%AF%E4%BB%80%E4%B9%88">CentOS是什么</a></li>
<li><a href="#centos-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">CentOS 8的新特性</a></li>
</ul>

<h2><a id="centos%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CentOS是什么</h2>
<p>下面简介摘自CentOS维基百科词条：</p>
<blockquote>
<p>CentOS（<strong>C</strong>ommunity <strong>Ent</strong>erprise <strong>O</strong>perating <strong>S</strong>ystem）是Linux发行版之一，它是来自于Red Hat Enterprise Linux（RHEL）依照开放源代码规定发布的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。CentOS 对上游代码的主要修改是为了移除不能自由使用的商标。2014年，CentOS宣布与Red Hat合作，但CentOS将会在新的委员会下继续运作，并不受RHEL的影响。</p>
</blockquote>
<p>比较通俗直白一点的说法，CentOS是Red Hat发行的商业版RHEL的开源替代版，也是作为Linux服务器使用的比较主流的开源操作系统之一。</p>
<p>CentOS第一次接触在2014年，也就是CentOS与Red Hat宣布合作的那一年。印象比较深的也是那一年发行的CentOS 7，由于其与Red Hat合作后，将RHEL 7的一些新特性例如<code>systemd</code>等引入，导致与其CentOS 6一些操作差距过大，再加上新系统教程较少，在系统上折腾了很久，也因此印象深刻。</p>
<p>截止本文撰稿，CentOS最新版本是<code>CentOS 8-2004</code>，其RHEL基础版为<code>RHEL 8.2</code>。</p>
<p><img src="media/15932531416990/15932603351520.jpg" alt="" /></p>
<p><img src="media/15932531416990/15932603152658.jpg" alt="" /></p>
<h2><a id="centos-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CentOS 8的新特性</h2>
<p>关于CentOS 8，主要的特性介绍如下：</p>
<p>CentOS项目是对<code>Red Hat Enterprise Linux</code>的100％兼容的重建，完全符合Red Hat的重新发布要求，并发布了一个新版本：<code>CentOS 8.0.1905</code>，适用于所有受支持的体系结构。</p>
<p>紧随<code>CentOS Linux 7.7</code>发行版之后，CentOS Linux 8现已正式发布，新版本基于<code>Red Hat Enterprise Linux 8.0</code>源，这意味着它具有混合云时代的所有强大的新特性和增强功能。</p>
<p><code>CentOS</code> 完全遵守 Red Hat 的再发行政策，并且致力与上游产品在功能上完全兼容。CentOS 对组件的修改主要是去除 Red Hat 的商标及美工图。</p>
<p>该版本还包含全新的 <code>CentOS Streams</code>，Centos Stream 是一个滚动发布的 Linux 发行版，它介于 Fedora Linux的上游开发和 RHEL 的下游开发之间而存在。你可以把 CentOS Streams 当成是用来体验最新红帽系 Linux 特性的一个版本，而无需等太久。</p>
<p>CentOS 8 主要改动和 <code>RedHat Enterprise Linux 8</code>是一致的，基于<code>Fedora 28</code>和内核版本 4.18, 为用户提供一个稳定的、安全的、一致的基础，跨越混合云部署，支持传统和新兴的工作负载所需的工具。此次发布的亮点包括：</p>
<p><strong>发行版</strong></p>
<p>通过 <code>BaseOS</code>和应用流 (<code>AppStream</code>) 仓库发布.</p>
<p><code>AppStream</code>是对传统 <code>rpm</code>格式的全新扩展，为一个组件同时提供多个主要版本</p>
<p><strong>软件管理</strong></p>
<p>YUM 包管理器基于 DNF 技术，提供模块化内容支持，增强了性能，并且提供了设计良好的 API 用于与其他工具集成</p>
<p><strong>Shell 和命令行工具</strong></p>
<p>RHEL 8 提供了版本控制工具: <code>Git 2.18</code>, <code>Mercurial 4.8</code>, 和 <code>Subversion 1.10.</code></p>
<p><strong>动态编程语言、Web 和数据库服务器</strong></p>
<p>Python 3.6 是默认的 Python 环境，有限支持 Python 2.7</p>
<p>Node.js 是在 RHEL 最新包含的，其他动态语言更新包括: PHP 7.2, Ruby 2.5, Perl 5.26, SWIG 3.0</p>
<p>RHEL 8 提供的数据库服务包括：MariaDB 10.3, MySQL 8.0, PostgreSQL 10, PostgreSQL 9.6, 和 Redis 5.</p>
<p>RHEL 8 提供Apache HTTP Server 2.4 以及首次引入的Nginx 1.14.</p>
<p>Squid 版本升级到 4.4 ，同时也首次提供Varnish Cache 6.0.</p>
<p><strong>桌面环境</strong></p>
<p>GNOME Shell 升级到 3.28.</p>
<p>GNOME 会话和显示管理使用 Wayland 作为默认的显示服务器，而 RHEL 7 默认的 X.Org server 依然提供</p>
<p><strong>安装程序以及镜像的创建</strong></p>
<p>Anaconda 安装程序可使用 LUKS2 磁盘加密，支持 NVDIMM 设备.</p>
<p>Image Builder 工具可以创建不同格式的自定义系统镜像，包括满足云平台的各种格式</p>
<p>支持使用硬件管理控制台 HMC 从 DVD 安装，同时也提供 IBM Z 主机的 Support Element (SE)</p>
<p><strong>内核</strong></p>
<p>扩展 Berkeley Packet Filtering (eBPF) 特性使得用户空间的各个点上附加自定义程序，包括 (sockets, trace points, packet reception) ，用于接收和处理数据。目前该特性还处于特性预览阶段</p>
<p>BPF Compiler Collection (BCC), 这是一个用来创建高效内核跟踪和操作的工具，目前处于技术预览阶段</p>
<p><strong>文件系统和存储</strong></p>
<p>LUKS version 2 (LUKS2) 格式替代旧的 LUKS (LUKS1) 格式. dm-crypt 子系统和 cryptsetup 工具现在使用 LUKS2 作为默认的加密卷格式</p>
<p><strong>安全</strong></p>
<p>默认的系统级的 加密策略, 用于配置核心加密子系统，覆盖 TLS, IPsec, SSH, DNSSEC, 和 Kerberos 协议。增加全新命令update-crypto-policies, 管理员可以轻松切换不同模式： <code>default</code>, <code>legacy</code>, <code>future</code>, 和 <code>fips</code>.</p>
<p>支持智能卡和硬件安全模块 (HSM) 的 PKCS #11</p>
<p><strong>网络</strong></p>
<p>nftables 框架替代 iptables 作为默认的网络包过滤工具</p>
<p>firewalld 守护进程使用 nftables 作为默认后端</p>
<p>支持 IPVLAN 虚拟网络驱动程序，用于连接多个容器</p>
<p>eXpress Data Path (XDP), XDP for Traffic Control (tc), 以及 Address Family eXpress Data Path (AF_XDP), 可作为部分 Berkeley Packet Filtering (eBPF) 扩展特性，目前还是技术预览阶段.</p>
<p><strong>虚拟化</strong></p>
<p>在RHEL8中创建的虚拟机中，现在支持并自动配置更现代的基于PCI Express的计算机类型（Q35）。这在虚拟设备的功能和兼容性方面提供了多种改进。</p>
<p>现在可以使用RHEL8Web控制台（也称为“驾驶舱”）创建和管理虚拟机。</p>
<p>qemu仿真器引入了沙箱功能，它为系统调用qemu可以执行的操作提供了可配置的限制，从而使虚拟机更加安全。</p>
<p><strong>编译器和开发工具</strong></p>
<p>GCC 编译器更新到 8.2 版本，支持更多 C++标准，更好的优化以及代码增强技术、提升警告和硬件特性支持</p>
<p>不同的代码生成、操作和调试工具现在可以处理 DWARF5 调试信息格式（体验阶段）</p>
<p>核心支持 eBPF 调试的工具包括BCC, PCP, 和 SystemTap.</p>
<p>glibc 库升级到 2.28 支持 Unicode 11, 更新的 Linux 系统调用，关键提升主要在 <code>DNS stub resolver</code> 、额外的安全加强和性能提升</p>
<p>RHEL 8 提供 <code>OpenJDK 11</code>, <code>OpenJDK 8</code>,<code>&lt;span&gt; &lt;/span&gt;IcedTea-Web</code>, 以及不同 Java 工具，如 <code>Ant</code>, <code>Maven</code>, 或 <code>Scala</code>.</p>
<p><strong>高可用和集群</strong></p>
<p>Pacemaker 集群资源管理器更新到最新版本 2.0.0, 修复了一系列 bug 以及功能做了提升</p>
<p>pcs 配置系统完全支持 Corosync 3, knet, 和节点名称</p>
<p><strong>相关链接</strong></p>
<p>CentOS 8 官方发行说明：</p>
<blockquote>
<p><a href="https://lists.centos.org/pipermail/centos-announce/2019-September/023449.html">https://lists.centos.org/pipermail/centos-announce/2019-September/023449.html</a></p>
</blockquote>
<p>完整的 RedHat 8 发行说明请看</p>
<blockquote>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.0_release_notes/overview">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.0_release_notes/overview</a></p>
</blockquote>
<p>目前来看，CentOS 8的修改相比CentOS 6-&gt;7的修改来说，在系统管理层次上，完善相对变动要多不少，加上云管环境的逐步推广，也加上了云的特性。</p>

]]></content>
  </entry>
  
</feed>
